[
    {
        "id": "f6f2187d.f17ca8",
        "type": "tab",
        "label": "Control Simulation",
        "disabled": false,
        "info": ""
    },
    {
        "id": "bb32693f1e238fb3",
        "type": "tab",
        "label": "Telegram Comands",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "974a61a99863234b",
        "type": "tab",
        "label": "Alert - Report - Grafana",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "8cbf2748df1bc57f",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "influxdb-SA-FMS",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://host.docker.internal:8086",
        "timeout": 10,
        "rejectUnauthorized": true
    },
    {
        "id": "227d6c6a69368223",
        "type": "telegram bot",
        "botname": "Smart Agriculture - Field Monitoring System",
        "usernames": "",
        "chatids": "",
        "baseapiurl": "",
        "testenvironment": false,
        "updatemode": "polling",
        "addressfamily": "",
        "pollinterval": "300",
        "usesocks": false,
        "sockshost": "",
        "socksprotocol": "socks5",
        "socksport": "6667",
        "socksusername": "anonymous",
        "sockspassword": "",
        "bothost": "",
        "botpath": "",
        "localbotport": "8443",
        "publicbotport": "8443",
        "privatekey": "",
        "certificate": "",
        "useselfsignedcertificate": false,
        "sslterminated": false,
        "verboselogging": false
    },
    {
        "id": "24f8f90e89fb0dcc",
        "type": "mqtt-broker",
        "name": "MQTT",
        "broker": "mosquitto-SA-FMS",
        "port": "1883",
        "clientid": "nodered",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "5",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "3cc11d24.ff01a2",
        "type": "comment",
        "z": "f6f2187d.f17ca8",
        "name": "WARNING: please check you have started this container with a volume that is mounted to /data\\n otherwise any flow changes are lost when you redeploy or upgrade the container\\n (e.g. upgrade to a more recent node-red docker image).\\n  If you are using named volumes you can ignore this warning.\\n Double click or see info side panel to learn how to start Node-RED in Docker to save your work",
        "info": "\nTo start docker with a bind mount volume (-v option), for example:\n\n```\ndocker run -it -p 1880:1880 -v /home/user/node_red_data:/data --name mynodered nodered/node-red\n```\n\nwhere `/home/user/node_red_data` is a directory on your host machine where you want to store your flows.\n\nIf you do not do this then you can experiment and redploy flows, but if you restart or upgrade the container the flows will be disconnected and lost. \n\nThey will still exist in a hidden data volume, which can be recovered using standard docker techniques, but that is much more complex than just starting with a named volume as described above.",
        "x": 390,
        "y": 80,
        "wires": []
    },
    {
        "id": "097e2d6989399613",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "Control Simulation",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 670,
        "y": 180,
        "wires": []
    },
    {
        "id": "c405962fedb7682e",
        "type": "mqtt out",
        "z": "f6f2187d.f17ca8",
        "name": "",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "24f8f90e89fb0dcc",
        "x": 630,
        "y": 240,
        "wires": []
    },
    {
        "id": "6ffb6578101f98d9",
        "type": "inject",
        "z": "f6f2187d.f17ca8",
        "name": "sensors/simulation/start",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "sensors/simulation/start",
        "payload": "avvio",
        "payloadType": "str",
        "x": 200,
        "y": 360,
        "wires": [
            [
                "c405962fedb7682e",
                "097e2d6989399613",
                "c3658e8c395688ef"
            ]
        ]
    },
    {
        "id": "7e16ef8e85ef6056",
        "type": "inject",
        "z": "f6f2187d.f17ca8",
        "name": "sensors/simulation/stop",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "sensors/simulation/stop",
        "payload": "stop",
        "payloadType": "str",
        "x": 200,
        "y": 400,
        "wires": [
            [
                "c405962fedb7682e",
                "097e2d6989399613",
                "92afd731d3dbf926"
            ]
        ]
    },
    {
        "id": "c3658e8c395688ef",
        "type": "link out",
        "z": "f6f2187d.f17ca8",
        "name": "link out start sim",
        "mode": "link",
        "links": [
            "986d77efaa034807"
        ],
        "x": 595,
        "y": 360,
        "wires": []
    },
    {
        "id": "92afd731d3dbf926",
        "type": "link out",
        "z": "f6f2187d.f17ca8",
        "name": "link out stop sim",
        "mode": "link",
        "links": [
            "3c24c8c58f47effd"
        ],
        "x": 595,
        "y": 400,
        "wires": []
    },
    {
        "id": "5b2e14e9b6cbd2fa",
        "type": "influxdb in",
        "z": "f6f2187d.f17ca8",
        "influxdb": "8cbf2748df1bc57f",
        "name": "",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "se4iot",
        "x": 510,
        "y": 500,
        "wires": [
            [
                "4d2dd74fee2521e2"
            ]
        ]
    },
    {
        "id": "538d7385b4eb041a",
        "type": "inject",
        "z": "f6f2187d.f17ca8",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "query",
                "v": "from(bucket: \"SA-FMS\")\t  |> range(start: -5000ms)\t  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\t  |> group(columns: [\"field_id\", \"sensor_type\"])\t  |> last()",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 240,
        "y": 500,
        "wires": [
            [
                "5b2e14e9b6cbd2fa"
            ]
        ]
    },
    {
        "id": "4d2dd74fee2521e2",
        "type": "debug",
        "z": "f6f2187d.f17ca8",
        "name": "Influx",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 750,
        "y": 500,
        "wires": []
    },
    {
        "id": "9e890f19a0dbdff1",
        "type": "inject",
        "z": "f6f2187d.f17ca8",
        "name": "sensors/simulation/config",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "sensors/simulation/config",
        "payload": "{\"initialWeather\":\"HEAVY_RAIN\",\"fields\":[{\"fieldId\":1,\"sensors\":{\"soilMoisture\":true,\"temperature\":true,\"ph\":true,\"salinity\":true,\"humidity\":true,\"rain\":true}},{\"fieldId\":2,\"sensors\":{\"soilMoisture\":true,\"temperature\":true,\"ph\":true,\"salinity\":true,\"humidity\":true,\"rain\":true}},{\"fieldId\":3,\"sensors\":{\"soilMoisture\":true,\"temperature\":true,\"ph\":true,\"salinity\":true,\"humidity\":true,\"rain\":true}}],\"interval\":5000}",
        "payloadType": "json",
        "x": 210,
        "y": 320,
        "wires": [
            [
                "c405962fedb7682e",
                "097e2d6989399613"
            ]
        ]
    },
    {
        "id": "7caf06a916b3fdaf",
        "type": "inject",
        "z": "f6f2187d.f17ca8",
        "name": "sensors/simulation/update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "sensors/simulation/update",
        "payload": "{\"weather\":\"HURRICANE\",\"interval\":5000,\"temperature\":24.5,\"humidity\":0.01}",
        "payloadType": "json",
        "x": 210,
        "y": 280,
        "wires": [
            [
                "c405962fedb7682e",
                "097e2d6989399613"
            ]
        ]
    },
    {
        "id": "c5cd4f257d9344ee",
        "type": "inject",
        "z": "f6f2187d.f17ca8",
        "name": "sensors/simulation/config/get",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "sensors/simulation/config/get",
        "payload": "GET CURRENT CONFIGURATION",
        "payloadType": "str",
        "x": 220,
        "y": 240,
        "wires": [
            [
                "c405962fedb7682e",
                "097e2d6989399613"
            ]
        ]
    },
    {
        "id": "e51026e420201b5b",
        "type": "mqtt in",
        "z": "f6f2187d.f17ca8",
        "name": "",
        "topic": "sensors/simulation/config/current",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "24f8f90e89fb0dcc",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 210,
        "y": 180,
        "wires": [
            [
                "097e2d6989399613"
            ]
        ]
    },
    {
        "id": "22c610fd78c1c732",
        "type": "inject",
        "z": "f6f2187d.f17ca8",
        "name": "Active Internal Debug",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "true",
        "payloadType": "bool",
        "x": 340,
        "y": 600,
        "wires": [
            [
                "fc2f8f38ed76a812"
            ]
        ]
    },
    {
        "id": "fc2f8f38ed76a812",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Set Internal Debug",
        "func": "global.set(\"internalDebug\", msg.payload);",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 600,
        "wires": []
    },
    {
        "id": "ce1e9cdc1195b46e",
        "type": "inject",
        "z": "f6f2187d.f17ca8",
        "name": "Deactive Internal Debug",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "false",
        "payloadType": "bool",
        "x": 340,
        "y": 640,
        "wires": [
            [
                "fc2f8f38ed76a812"
            ]
        ]
    },
    {
        "id": "e1ef453bd63ae7bb",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/start",
        "description": "",
        "registercommand": false,
        "language": "",
        "scope": "default",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 270,
        "y": 200,
        "wires": [
            [
                "4e14f0c4c6142568"
            ],
            []
        ]
    },
    {
        "id": "4e14f0c4c6142568",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "/help",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve stored chat data or an empty array.\nvar storedChats = global.get('chats') || [];\nvar chats = new Map(storedChats);\n\n// Check if the chat context exists; if not, create it.\nif (!chats.has(chatContextKey)) {\n    chats.set(chatContextKey, { active: true });\n    global.set('chats', Array.from(chats.entries()));\n}\n\n// Check if alerts are activated for the current chat.\nvar helpMessage = \"\\n\";\nhelpMessage += \"\\nYou are welcome: <strong>\" + msg.originalMessage.from.username + \"</strong>\";\nhelpMessage += \"\\nThis Bot will allow you to manage the entire <strong>Smart Agriculture - Field Monitoring System</strong> project simulation.\"\nhelpMessage += \"\\n\";\nhelpMessage += \"\\nYour chat id is <strong>\" + chatId + \"</strong>\";\nhelpMessage += \"\\n\";\nhelpMessage += chats.has(chatContextKey) && chats.get(chatContextKey) ? \"\\nAlerts have been <strong>activated</strong> for this chat!\" : \"\\nAlerts have been <strong>deactivated</strong> for this chat!\";\nhelpMessage += \"\\n\";\n\n// Display a list of available commands.\nhelpMessage += \"\\nHere is a short list of commands:\";\nhelpMessage += \"\\n/help - Shows Help Messagge.\";\nhelpMessage += \"\\n/set_simulation - Set all simumaltion parameters.\";\nhelpMessage += \"\\n/update_simulation_condition - Update the simulation condition.\"\nhelpMessage += \"\\n/current_configuration - Gets the current configuration of the sensor simulator.\"\nhelpMessage += \"\\n/toggle_alert - Enable or disable the reception of alerts.\"\n\nhelpMessage += \"\\n\";\n\n\n\nmsg.payload.content = helpMessage;\nmsg.payload.options = {\n    parse_mode: 'HTML',\n    reply_parameters: {\n        message_id: msg.payload.messageId\n    }\n}\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 200,
        "wires": [
            [
                "2e0f652a39c75081"
            ]
        ]
    },
    {
        "id": "2e0f652a39c75081",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 690,
        "y": 200,
        "wires": [
            [
                "ada578badb666345"
            ]
        ]
    },
    {
        "id": "549bf0869dbbd4e3",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/help",
        "description": "Show Helper",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 270,
        "y": 140,
        "wires": [
            [
                "4e14f0c4c6142568"
            ],
            []
        ]
    },
    {
        "id": "ada578badb666345",
        "type": "debug",
        "z": "bb32693f1e238fb3",
        "name": "Sender",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 200,
        "wires": []
    },
    {
        "id": "ac765d6f9de4dc68",
        "type": "catch",
        "z": "bb32693f1e238fb3",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 480,
        "y": 140,
        "wires": [
            [
                "583ccf3067d7ba51"
            ]
        ]
    },
    {
        "id": "583ccf3067d7ba51",
        "type": "debug",
        "z": "bb32693f1e238fb3",
        "name": "catch",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 670,
        "y": 140,
        "wires": []
    },
    {
        "id": "286f27e7f2a30e5b",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/set_simulation",
        "description": "Set all the settings of the sensor simulator",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 300,
        "y": 260,
        "wires": [
            [
                "07fa96347a7bd9a9",
                "caedbe9a15ad2ed7",
                "149101f4987ee626"
            ],
            []
        ]
    },
    {
        "id": "07fa96347a7bd9a9",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Keyboard SetSimulation Step 0 ",
        "func": "// Define message options with an inline keyboard for user interaction.\nvar opts = {\n  reply_to_message_id: msg.payload.messageId, // Reply to the specific message ID.\n  reply_markup: JSON.stringify({\n    \"inline_keyboard\": [[\n      {\n        \"text\": \"Yes\", // Button with \"Yes\" text.\n        \"callback_data\": \"S0 YES\" // Data sent when the button is pressed.\n      },\n      {\n        \"text\": \"No\", // Button with \"No\" text.\n        \"callback_data\": \"S0 NO\" // Data sent when the button is pressed.\n      }]\n    ]\n  })\n};\n// Define the message content asking for user confirmation.\nmsg.payload.content = 'Are you sure you want to set a different agricultural field simulation?';\n\n// Attach the options to the message payload.\nmsg.payload.options = opts;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 260,
        "wires": [
            [
                "3d9ca55109792442"
            ]
        ]
    },
    {
        "id": "3d9ca55109792442",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "sendTextMessage",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 770,
        "y": 260,
        "wires": [
            [
                "ece669d52b049dd7"
            ]
        ]
    },
    {
        "id": "ece669d52b049dd7",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save IdMessaggio in ChatContex",
        "func": "// Validate chatId: it must exist and be a number.\nvar chatId = msg.payload.chatId;\nif (!chatId || typeof chatId !== \"number\") {\n    node.error(\"Invalid chatId: \" + chatId);\n    return null;\n}\n\nvar chatContextKey = \"chat_\" + chatId;\nvar chatContext = flow.get(chatContextKey) || {}; // Retrieve stored chat context or initialize an empty object.\n\n// Store message IDs related to settings.\nchatContext.messageIdToReplaySettings = msg.payload.messageId;\nchatContext.messageIdSettings = msg.payload.sentMessageId;\n\nflow.set(chatContextKey, chatContext); // Save updated chat context in the flow.\n\n// Debugging: Log chat context if internal debugging is enabled.\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: chatContextKey=\" + chatContextKey + \", content=\" + JSON.stringify(chatContext));\n}",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1020,
        "y": 260,
        "wires": []
    },
    {
        "id": "2587aecf2d9cafb2",
        "type": "telegram event",
        "z": "bb32693f1e238fb3",
        "name": "",
        "bot": "227d6c6a69368223",
        "event": "callback_query",
        "autoanswer": false,
        "x": 260,
        "y": 2000,
        "wires": [
            [
                "94b59fc68cf6bccd",
                "caedbe9a15ad2ed7"
            ]
        ]
    },
    {
        "id": "a2fe17dca5d86712",
        "type": "switch",
        "z": "bb32693f1e238fb3",
        "name": "SCancel \\n S0 \\n S1 \\n S2 \\n S3 \\n S4 \\n S5 \\n otherwise",
        "property": "payload.content",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "SCancel",
                "vt": "str"
            },
            {
                "t": "regex",
                "v": "^S0",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^S1",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^S2",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^S3",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^S4",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^S5",
                "vt": "str",
                "case": false
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 8,
        "x": 640,
        "y": 2000,
        "wires": [
            [
                "fd921968d712568a"
            ],
            [
                "802ed589f7c585ee"
            ],
            [
                "66e574831f702cd4"
            ],
            [
                "a9f704d0090e9cb0"
            ],
            [
                "c9a56ef7f94a25f7"
            ],
            [
                "69d9ae7795d0e005"
            ],
            [
                "3b1d37ce65c4a985"
            ],
            []
        ]
    },
    {
        "id": "802ed589f7c585ee",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Keyboard SetSimulation Step 1",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if the chat context or messageIdSettings exists\nif (!chatContext || !chatContext.messageIdSettings) {\n    node.error(\"Message ID non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the user's choice from the message payload\nvar userChoice = msg.payload.content; // Example: \"S0 YES\" or \"S0 NO\"\"\n\n// Prepare the new message content based on the user's choice\nvar newText;\nif (userChoice === \"S0 YES\") {\n    newText = \"Great, let's get started!!! \\r\\n\\r\\nHow many agricultural fields do you want to simulate this time?\";\n} else if (userChoice === \"S0 NO\") {\n    newText = \"OK, you can reuse the /set_simulation command when you are <strong>ready to change the simulation settings</strong>!\";\n} else {\n    newText = \"Invalid choice!\";\n}\n\n// Prepare an empty inline keyboard to remove any existing buttons\nvar reply_markup_empty = JSON.stringify({\n    \"inline_keyboard\": [] // Removes the inline keyboard\n});\n\n// Prepare a new inline keyboard with field selection options\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"1Ô∏è‚É£\",\n            \"callback_data\": \"S1 1\"\n        },\n        {\n            \"text\": \"2Ô∏è‚É£\",\n            \"callback_data\": \"S1 2\"\n        },\n        {\n            \"text\": \"3Ô∏è‚É£\",\n            \"callback_data\": \"S1 3\"\n        }\n    ],\n    [\n        {\n            \"text\": \"4Ô∏è‚É£\",\n            \"callback_data\": \"S1 4\"\n        },\n        {\n            \"text\": \"5Ô∏è‚É£\",\n            \"callback_data\": \"S1 5\"\n        },\n        {\n            \"text\": \"6Ô∏è‚É£\",\n            \"callback_data\": \"S1 6\"\n        }\n    ],\n    [{\n        \"text\": \"‚ùå   ABORT   ‚ùå\",\n        \"callback_data\": \"SCancel\"\n    }\n    ]] // Updated keyboard\n});\n\n// If the user selects \"YES,\" display the new keyboard with field options\nif (userChoice === \"S0 YES\") {\n    var options = {\n        chat_id: msg.payload.chatId,\n        reply_markup: reply_markup,\n        message_id: chatContext.messageIdSettings,\n        parse_mode: 'HTML'\n    };\n    msg.payload.type = 'editMessageText';\n    msg.payload.content = newText;\n    msg.payload.options = options;\n} else {\n    // If the user selects \"NO,\" remove the inline keyboard\n    var options = {\n        chat_id: msg.payload.chatId,\n        reply_markup: reply_markup_empty,\n        message_id: chatContext.messageIdSettings,\n        parse_mode: 'HTML'\n    };\n    msg.payload.type = 'editMessageText';\n    msg.payload.content = newText;\n    msg.payload.options = options;\n\n    // Remove the message ID reference from the chat context\n    delete chatContext.messageIdSettings;\n    flow.set(chatContextKey, chatContext);\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 1940,
        "wires": [
            [
                "7da069185bf6891a"
            ]
        ]
    },
    {
        "id": "7da069185bf6891a",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "sendTextMessage",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1450,
        "y": 2040,
        "wires": [
            []
        ]
    },
    {
        "id": "fd921968d712568a",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Abort SetSimulation",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if the chat context or messageIdSettings exists\nif (!chatContext || !chatContext.messageIdSettings) {\n    node.error(\"Message ID non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\n// Remove the settingSimulationContext property if it exists\nvar settingSimulationContext = chatContext.settingSimulationContext;\nif (settingSimulationContext) {\n    delete chatContext.settingSimulationContext;\n}\n\n// Define the new response text\nvar newText = \"OK, you can reuse the /set_simulation command when you are <strong>ready to change the simulation settings</strong>!\";\n\n// Define an empty inline keyboard to remove any existing buttons\nvar reply_markup_empty = JSON.stringify({\n    \"inline_keyboard\": [] // Removes the inline keyboard if present\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup_empty,\n    message_id: chatContext.messageIdSettings, // Reference the original message to edit\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Remove message-related properties from the chat context\ndelete chatContext.messageIdToReplaySettings;\ndelete chatContext.messageIdSettings;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1900,
        "wires": [
            [
                "7da069185bf6891a",
                "20b3b83c60c12de1"
            ]
        ]
    },
    {
        "id": "66e574831f702cd4",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save the number of fields and present Keyboard Step 2 Sensors",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if the chat context or messageIdSettings exists\nif (!chatContext || !chatContext.messageIdSettings) {\n    node.error(\"Message ID non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\n// Initialize or retrieve the simulation settings context\nvar settingSimulationContext = chatContext.settingSimulationContext || {};\n\n// Set up the new simulation settings\nsettingSimulationContext.newSetting = {\n    total_field: parseInt(msg.payload.content.split(\" \")[1]),\n    courrent_field: 1,\n    next_field: parseInt(msg.payload.content.split(\" \")[1]) > 1 ? 2 : 1\n};\n\n// Store the updated simulation settings in the chat context\nchatContext.settingSimulationContext = settingSimulationContext;\n\n// Debugging: Log the stored simulation context if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Salvato nel Flow: settingSimulationContext=\" + JSON.stringify(settingSimulationContext));\n}\n\n// Prepare the response message\nvar newText = \"OK, we have \" + msg.payload.content.split(\" \")[1] + \" farmlands! Great! \\r\\nNow we have to decide which sensors will be on the fields. \\r\\nLet's start with field number 1. \\r\\nSelect the sensors that are present on field number 1:\";\n\n// Define the inline keyboard for sensor selection\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"üì° ALL SENSORS @ FIELD 1 üì°\",\n            \"callback_data\": \"S2 ALL 1\"\n        }],\n    [\n        {\n            \"text\": \"üî≤ Soil Moisture\",\n            \"callback_data\": \"S2 11 1\"\n        },\n        {\n            \"text\": \"üî≤ Temperature\",\n            \"callback_data\": \"S2 21 1\"\n        }],\n    [\n        {\n            \"text\": \"üî≤ Soil Ph\",\n            \"callback_data\": \"S2 31 1\"\n        },\n        {\n            \"text\": \"üî≤ Water Salinity\",\n            \"callback_data\": \"S2 41 1\"\n        }],\n    [\n        {\n            \"text\": \"üî≤ Relative Humidity\",\n            \"callback_data\": \"S2 51 1\"\n        },\n        {\n            \"text\": \"üî≤ Rainfall\",\n            \"callback_data\": \"S2 61 1\"\n        }],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"SCancel\"\n        }]\n    ]\n});\n\n// Define message options for editing the text\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdSettings\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 1980,
        "wires": [
            [
                "7da069185bf6891a"
            ]
        ]
    },
    {
        "id": "a2103770cb63c5b0",
        "type": "comment",
        "z": "bb32693f1e238fb3",
        "name": "SET SIMULATION \\n \\n SCancel \\n The SCancel step is used to cancel the process of creating a new setting.\\n \\n S0\\n The S0 step is used to ask the user if they wish to start a new setting.\\n \\n S1\\n Step S1 is for specifying the number of farm fields, between 1 and 6.\\n \\n S2\\n Step S2 allows the user to indicate which sensors are present in each agricultural field.\\n  This step is iterated until the S2 OK or S2 ALL command is received.\\n \\n S2 OK and S2 ALL\\n Steps S2 OK and S2 ALL are used to confirm the selection of sensors for the current agricultural field.\\n \\n S3\\n Step S3 is used to define the starting climatic conditions that will be applied to all agricultural fields in the simulation.\\n \\n S4\\n Step S4 presents a summary of the configuration and requires confirmation to proceed.\\n \\n S5\\n Step S5 concludes the process of creating a new setting by sending it to the simulation server.",
        "info": "# Italiano\n---\n\n# SCancel\nLo step **SCancel** serve per annullare il processo di creazione di un nuovo settaggio.\n\n# S0\nLo step **S0** serve per chiedere all'utente se desidera iniziare un nuovo settaggio.\n\n# S1\nLo step **S1** consente di specificare il numero di campi agricoli, compreso tra 1 e 6.\n\n# S2\nLo step **S2** permette di indicare quali sensori sono presenti in ciascun campo agricolo.\n\nQuesto step viene iterato fino a ricevere il comando **S2 OK** o **S2 ALL**.\n\n# S2 OK e S2 ALL\nGli step **S2 OK** e **S2 ALL** servono per confermare la selezione dei sensori per il campo agricolo corrente.\n\n# S3\nLo step **S3** consente di definire le condizioni climatiche di partenza che saranno applicate a tutti i campi agricoli nella simulazione.\n\n# S4\nLo step **S4** presenta un riepilogo della configurazione e richiede conferma per procedere.\n\n# S5\nLo step **S5** conclude il processo di creazione di un nuovo settaggio, inviandolo al server di simulazione.\n\n<br><br><br>\n\n# English\n---\n# SCancel\nThe **SCancel** step is used to cancel the process of creating a new setting.\n\n# S0\nThe **S0** step is used to ask the user if they wish to start a new setting.\n\n# S1\nStep **S1** is for specifying the number of farm fields, between 1 and 6.\n\n# S2\nStep **S2** allows the user to indicate which sensors are present in each agricultural field.\n\nThis step is iterated until the **S2 OK** or **S2 ALL** command is received.\n\n# S2 OK and S2 ALL\nSteps **S2 OK** and **S2 ALL** are used to confirm the selection of sensors for the current agricultural field.\n\n# S3\nStep **S3** is used to define the starting climatic conditions that will be applied to all agricultural fields in the simulation.\n\n# S4\nStep **S4** presents a summary of the configuration and requires confirmation to proceed.\n\n# S5\nStep **S5** concludes the process of creating a new setting by sending it to the simulation server.",
        "x": 970,
        "y": 1540,
        "wires": []
    },
    {
        "id": "2f75cbe1fc45b92d",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save, check next_field, question weather",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if the chat context or messageIdSettings exists\nif (!chatContext || !chatContext.messageIdSettings) {\n    node.error(\"Message ID non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\n// Validate the simulation settings context\nif (!chatContext.settingSimulationContext || !chatContext.settingSimulationContext.newSetting || !Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field) || !Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field) || !Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field)) {\n    node.error(\"settingSimulationContext non trovato nel Flow Context per chatId: \" + chatId);\n    node.error(\"!chatContext.settingSimulationContext: \" + !chatContext.settingSimulationContext);\n    node.error(\"!chatContext.settingSimulationContext.newSetting: \" + !chatContext.settingSimulationContext.newSetting);\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field));\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field));\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field));\n    return null;\n}\n\n// Check if fields_configuration exists when configuring more than one field\nif (!chatContext.settingSimulationContext.newSetting.fields_configuration && chatContext.settingSimulationContext.newSetting.total_field > 1 && chatContext.settingSimulationContext.newSetting.courrent_field > 1) {\n    node.error(\"fields_configuration non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\nvar newSetting = chatContext.settingSimulationContext.newSetting;\n\n// Initialize fields_configuration as an object if it doesn't exist\nvar fields_configuration = newSetting.fields_configuration || {};\n\n// Extract command from the user input (e.g., \"S2 ALL #F\") \nvar messageCode = msg.payload.content.split(\" \");\nvar command = messageCode[1];\nswitch (command) {\n    case \"ALL\":\n        // Assign all sensor types to the current field\n        fields_configuration[newSetting.courrent_field] = {\n            soilMoisture: true,\n            temperature: true,\n            soilPh: true,\n            waterSalinity: true,\n            relativeHumidity: true,\n            rainfall: true\n        };\n        newSetting.fields_configuration = fields_configuration;\n        break;\n    case \"OK\":\n        // Do nothing if \"OK\" is selected\n        break;\n}\n\n// If there are more fields to configure, proceed to the next field\nif (chatContext.settingSimulationContext.newSetting.total_field > chatContext.settingSimulationContext.newSetting.courrent_field) {\n    chatContext.settingSimulationContext.newSetting.courrent_field = chatContext.settingSimulationContext.newSetting.courrent_field + 1;\n\n    // Prepare a new inline keyboard for selecting sensors for the next field\n    var newText = \"OK, we have \" + chatContext.settingSimulationContext.newSetting.total_field + \" farmlands! Great! \\r\\nNow we have to decide which sensors will be on the fields. \\r\\nSelect the sensors that are present on field number \" + chatContext.settingSimulationContext.newSetting.courrent_field + \" :\";\n\n    // Inline keyboard base\n    var inline_keyboard = [\n        [\n            {\n                \"text\": \"üì° ALL SENSORS @ FIELD \" + newSetting.courrent_field + \" üì°\",\n                \"callback_data\": \"S2 ALL \" + chatContext.settingSimulationContext.newSetting.courrent_field\n            }\n        ],\n        [\n            {\n                \"text\": \"üî≤ Soil Moisture\",\n                \"callback_data\": \"S2 11 \" + chatContext.settingSimulationContext.newSetting.courrent_field\n            },\n            {\n                \"text\": \"üî≤ Temperature\",\n                \"callback_data\": \"S2 21 \" + chatContext.settingSimulationContext.newSetting.courrent_field\n            }\n        ],\n        [\n            {\n                \"text\": \"üî≤ Soil Ph\",\n                \"callback_data\": \"S2 31 \" + chatContext.settingSimulationContext.newSetting.courrent_field\n            },\n            {\n                \"text\": \"üî≤ Water Salinity\",\n                \"callback_data\": \"S2 41 \" + chatContext.settingSimulationContext.newSetting.courrent_field\n            }\n        ],\n        [\n            {\n                \"text\": \"üî≤ Relative Humidity\",\n                \"callback_data\": \"S2 51 \" + chatContext.settingSimulationContext.newSetting.courrent_field\n            },\n            {\n                \"text\": \"üî≤ Rainfall\",\n                \"callback_data\": \"S2 61 \" + chatContext.settingSimulationContext.newSetting.courrent_field\n            }\n        ],\n        [\n            {\n                \"text\": \"‚ùå   ABORT   ‚ùå\",\n                \"callback_data\": \"SCancel\"\n            }\n        ]\n    ];\n\n    // Convert inline keyboard to JSON\n    var reply_markup = JSON.stringify({ \"inline_keyboard\": inline_keyboard });\n\n    var options = {\n        chat_id: msg.payload.chatId,\n        reply_markup: reply_markup,\n        message_id: chatContext.messageIdSettings\n    };\n\n    msg.payload.type = 'editMessageText';\n    msg.payload.content = newText;\n    msg.payload.options = options;\n\n    return msg;\n}\n\n// If all fields are configured, prompt for weather conditions\nvar newText = \"Great! \\r\\nWe have finished the configuration related to the sensors on the agricultural fields! \\r\\nNow you need to decide what weather condition is present on your farmland. \\r\\n\\r\\nSelect one of the following conditions: \";\n\n// Prepare inline keyboard for selecting weather conditions\nvar reply_markup_empty = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"‚òÄÔ∏è Sunny ‚òÄÔ∏è\",\n            \"callback_data\": \"S3 SUNNY\"\n        }],\n    [\n        {\n            \"text\": \"‚òÅÔ∏è Cloudy ‚òÅÔ∏è\",\n            \"callback_data\": \"S3 CLOUDY \"\n        }\n    ],\n    [\n        {\n            \"text\": \"üå¶Ô∏è Light Rain üå¶Ô∏è\",\n            \"callback_data\": \"S3 LIGHT_RAIN \"\n        }\n    ],\n    [\n        {\n            \"text\": \"üåßÔ∏è Moderate Rain üåßÔ∏è\",\n            \"callback_data\": \"S3 MODERATE_RAIN\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚õàÔ∏è Heavy Rain ‚õàÔ∏è\",\n            \"callback_data\": \"S3 HEAVY_RAIN\"\n        }\n    ],\n    [\n        {\n            \"text\": \"üåÄ Hurricane üåÄ\",\n            \"callback_data\": \"S3 HURRICANE\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"SCancel\"\n        }]\n    ]\n});\n\n// Configure message options to update the text\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup_empty,\n    message_id: chatContext.messageIdSettings\n};\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 2040,
        "wires": [
            [
                "7da069185bf6891a"
            ]
        ]
    },
    {
        "id": "a9f704d0090e9cb0",
        "type": "switch",
        "z": "bb32693f1e238fb3",
        "name": "S2 OK \\n S2 ALL \\n S2",
        "property": "payload.content",
        "propertyType": "msg",
        "rules": [
            {
                "t": "regex",
                "v": "^S2 OK",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^S2 ALL",
                "vt": "str",
                "case": false
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 3,
        "x": 860,
        "y": 2060,
        "wires": [
            [
                "2f75cbe1fc45b92d"
            ],
            [
                "2f75cbe1fc45b92d"
            ],
            [
                "11a5c5289706988e"
            ]
        ]
    },
    {
        "id": "11a5c5289706988e",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save, change status to keyboard",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if the chat context or messageIdSettings exists\nif (!chatContext || !chatContext.messageIdSettings) {\n    node.error(\"Message ID non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\n// Validate the simulation settings context\nif (!chatContext.settingSimulationContext || !chatContext.settingSimulationContext.newSetting || !Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field) || !Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field) || !Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field)) {\n    node.error(\"settingSimulationContext non trovato nel Flow Context per chatId: \" + chatId);\n    node.error(\"!chatContext.settingSimulationContext: \" + !chatContext.settingSimulationContext);\n    node.error(\"!chatContext.settingSimulationContext.newSetting: \" + !chatContext.settingSimulationContext.newSetting);\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field));\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field));\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field));\n    return null;\n}\n\n// Ensure fields_configuration exists when configuring more than one field\nif (!chatContext.settingSimulationContext.newSetting.fields_configuration && chatContext.settingSimulationContext.newSetting.total_field > 1 && chatContext.settingSimulationContext.newSetting.courrent_field > 1) {\n    node.error(\"fields_configuration non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\nvar newSetting = chatContext.settingSimulationContext.newSetting;\n\n// Extract the message components (e.g., \"S2 11 #F\") \nvar messageCode = msg.payload.content.split(\" \");\n\n// Initialize fields_configuration as an object if it doesn't exist\nvar fields_configuration = newSetting.fields_configuration || {};\n\n// Ensure that the current field key exists in fields_configuration\nif (!fields_configuration[newSetting.courrent_field]) {\n    fields_configuration[newSetting.courrent_field] = {\n        soilMoisture: false,\n        temperature: false,\n        soilPh: false,\n        waterSalinity: false,\n        relativeHumidity: false,\n        rainfall: false\n    };\n}\n\n// Ensure that the specified field in the message matches the current field\nif (parseInt(messageCode[2]) !== newSetting.courrent_field) {\n    node.error(\"Il campo non corrisponde al campo corrente\");\n}\n\n// Determine the sensor type and boolean value from the sensor code\nvar sensorType = messageCode[1][0]; // First character of the second element\nvar sensorValue = messageCode[1][1] === \"1\"; // Convert \"1\" to true and \"0\" to false\n\n// Update the field's sensor settings based on sensorType\nswitch (sensorType) {\n    case \"1\":\n        fields_configuration[newSetting.courrent_field].soilMoisture = sensorValue;\n        break;\n    case \"2\":\n        fields_configuration[newSetting.courrent_field].temperature = sensorValue;\n        break;\n    case \"3\":\n        fields_configuration[newSetting.courrent_field].soilPh = sensorValue;\n        break;\n    case \"4\":\n        fields_configuration[newSetting.courrent_field].waterSalinity = sensorValue;\n        break;\n    case \"5\":\n        fields_configuration[newSetting.courrent_field].relativeHumidity = sensorValue;\n        break;\n    case \"6\":\n        fields_configuration[newSetting.courrent_field].rainfall = sensorValue;\n        break;\n}\n\n// Save the updated fields_configuration\nnewSetting.fields_configuration = fields_configuration;\n\n// Define icons and toggle values for each sensor\nvar iconS1 = fields_configuration[newSetting.courrent_field].soilMoisture ? \"‚úÖ\" : \"üî≤\";\nvar valS1 = fields_configuration[newSetting.courrent_field].soilMoisture ? \"0\" : \"1\";\n\nvar iconS2 = fields_configuration[newSetting.courrent_field].temperature ? \"‚úÖ\" : \"üî≤\";\nvar valS2 = fields_configuration[newSetting.courrent_field].temperature ? \"0\" : \"1\";\n\nvar iconS3 = fields_configuration[newSetting.courrent_field].soilPh ? \"‚úÖ\" : \"üî≤\";\nvar valS3 = fields_configuration[newSetting.courrent_field].soilPh ? \"0\" : \"1\";\n\nvar iconS4 = fields_configuration[newSetting.courrent_field].waterSalinity ? \"‚úÖ\" : \"üî≤\";\nvar valS4 = fields_configuration[newSetting.courrent_field].waterSalinity ? \"0\" : \"1\";\n\nvar iconS5 = fields_configuration[newSetting.courrent_field].relativeHumidity ? \"‚úÖ\" : \"üî≤\";\nvar valS5 = fields_configuration[newSetting.courrent_field].relativeHumidity ? \"0\" : \"1\";\n\nvar iconS6 = fields_configuration[newSetting.courrent_field].rainfall ? \"‚úÖ\" : \"üî≤\";\nvar valS6 = fields_configuration[newSetting.courrent_field].rainfall ? \"0\" : \"1\";\n\n// Create the inline keyboard for sensor selection\nvar inline_keyboard = [\n    [\n        {\n            \"text\": \"üì° ALL SENSORS @ FIELD \" + newSetting.courrent_field + \" üì°\",\n            \"callback_data\": \"S2 ALL \" + newSetting.courrent_field\n        }\n    ],\n    [\n        {\n            \"text\": iconS1 + \" Soil Moisture\",\n            \"callback_data\": \"S2 1\" + valS1 + \" \" + newSetting.courrent_field\n        },\n        {\n            \"text\": iconS2 + \" Temperature\",\n            \"callback_data\": \"S2 2\" + valS2 + \" \" + newSetting.courrent_field\n        }\n    ],\n    [\n        {\n            \"text\": iconS3 + \" Soil Ph\",\n            \"callback_data\": \"S2 3\" + valS3 + \" \" + newSetting.courrent_field\n        },\n        {\n            \"text\": iconS4 + \" Water Salinity\",\n            \"callback_data\": \"S2 4\" + valS4 + \" \" + newSetting.courrent_field\n        }\n    ],\n    [\n        {\n            \"text\": iconS5 + \" Relative Humidity\",\n            \"callback_data\": \"S2 5\" + valS5 + \" \" + newSetting.courrent_field\n        },\n        {\n            \"text\": iconS6 + \" Rainfall\",\n            \"callback_data\": \"S2 6\" + valS6 + \" \" + newSetting.courrent_field\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"SCancel\"\n        }\n    ]\n];\n\n// Add a button for confirmation or proceeding to the next field\nif (chatContext.settingSimulationContext.newSetting.total_field == chatContext.settingSimulationContext.newSetting.courrent_field) { // Sostituisci `someCondition` con la tua condizione\n    // Debug\n    if (global.get(\"internalDebug\")) {\n        node.warn(\"ADDING CONFIRMATION BUTTON\");\n    }\n    inline_keyboard[inline_keyboard.length - 1].push({\n        \"text\": \"‚úîÔ∏è CONFIRMATION ‚úîÔ∏è\",\n        \"callback_data\": \"S2 OK \" + newSetting.courrent_field\n    });\n} else {\n    inline_keyboard[inline_keyboard.length - 1].push({\n        \"text\": \"üèûÔ∏è üöú NEXT FIELD üöú üèûÔ∏è\",\n        \"callback_data\": \"S2 OK \" + newSetting.courrent_field\n    });\n}\n\n// Convert inline keyboard to JSON\nvar reply_markup = JSON.stringify({ \"inline_keyboard\": inline_keyboard });\n\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdSettings\n};\n\n// Prepare the response message\nvar newText = \"OK, we have \" + newSetting.total_field + \" farmlands! Great! \\r\\nNow we have to decide which sensors will be on the fields. \\r\\nSelect the sensors that are present on field number \" + newSetting.courrent_field + \" :\";\n\n// Update the message content\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 2080,
        "wires": [
            [
                "7da069185bf6891a"
            ]
        ]
    },
    {
        "id": "c9a56ef7f94a25f7",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save and prensent interval",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if the chat context or messageIdSettings exists\nif (!chatContext || !chatContext.messageIdSettings) {\n    node.error(\"Message ID non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\n// Validate the simulation settings context\nif (!chatContext.settingSimulationContext || !chatContext.settingSimulationContext.newSetting || !Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field) || !Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field) || !Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field)) {\n    node.error(\"settingSimulationContext non trovato nel Flow Context per chatId: \" + chatId);\n    node.error(\"!chatContext.settingSimulationContext: \" + !chatContext.settingSimulationContext);\n    node.error(\"!chatContext.settingSimulationContext.newSetting: \" + !chatContext.settingSimulationContext.newSetting);\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field));\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field));\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field));\n    return null;\n}\n\n// Ensure fields_configuration exists when configuring more than one field\nif (!chatContext.settingSimulationContext.newSetting.fields_configuration && chatContext.settingSimulationContext.newSetting.total_field > 1 && chatContext.settingSimulationContext.newSetting.courrent_field > 1) {\n    node.error(\"fields_configuration non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\nvar newSetting = chatContext.settingSimulationContext.newSetting;\n\n// Extract the selected weather condition (e.g., \"S3 HURRICANE\") \nvar messageCode = msg.payload.content.split(\" \");\n\n// Save the initial weather condition\nnewSetting.initialWeather = messageCode[1];\n\n// Update the chat context with the new setting\nchatContext.settingSimulationContext.newSetting = newSetting;\n\n// Define the inline keyboard for selecting the sensor update interval\nvar inline_keyboard = [\n    [\n        {\n            \"text\": \"DEFAULT 5 sec\",\n            \"callback_data\": \"S4 5000\"\n        }\n    ],\n    [\n        {\n            \"text\": \"1 sec\",\n            \"callback_data\": \"S4 1000\"\n        },\n        {\n            \"text\": \"2 sec\",\n            \"callback_data\": \"S4 2000\"\n        }\n    ],\n    [\n        {\n            \"text\": \"10 sec\",\n            \"callback_data\": \"S4 10000\"\n        },\n        {\n            \"text\": \"15 sec\",\n            \"callback_data\": \"S4 15000\"\n        }\n    ],\n    [\n        {\n            \"text\": \"30 sec\",\n            \"callback_data\": \"S4 30000\"\n        },\n        {\n            \"text\": \"1 min\",\n            \"callback_data\": \"S4 60000\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"SCancel\"\n        }\n    ]\n];\n\n// Convert the inline keyboard to JSON format\nvar reply_markup = JSON.stringify({ \"inline_keyboard\": inline_keyboard });\n\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdSettings\n};\n\n// Prepare the response message\nvar newText = \"Excellent! \\r\\n\\r\\nNow all that remains is to determine how often the sensors will update. \\r\\n\\r\\nSelect the time interval from those present:\";\n\n// Update the message content\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 2160,
        "wires": [
            [
                "7da069185bf6891a"
            ]
        ]
    },
    {
        "id": "69d9ae7795d0e005",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Saves and summarises the configuration",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if the chat context or messageIdSettings exists\nif (!chatContext || !chatContext.messageIdSettings) {\n    node.error(\"Message ID non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\n// Validate the simulation settings context\nif (!chatContext.settingSimulationContext || !chatContext.settingSimulationContext.newSetting || !Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field) || !Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field) || !Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field)) {\n    node.error(\"settingSimulationContext non trovato nel Flow Context per chatId: \" + chatId);\n    node.error(\"!chatContext.settingSimulationContext: \" + !chatContext.settingSimulationContext);\n    node.error(\"!chatContext.settingSimulationContext.newSetting: \" + !chatContext.settingSimulationContext.newSetting);\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field));\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field));\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field));\n    return null;\n}\n\n// Ensure fields_configuration exists when configuring more than one field\nif (!chatContext.settingSimulationContext.newSetting.fields_configuration && chatContext.settingSimulationContext.newSetting.total_field > 1 && chatContext.settingSimulationContext.newSetting.courrent_field > 1) {\n    node.error(\"fields_configuration non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\nvar newSetting = chatContext.settingSimulationContext.newSetting;\n\n// Extract the selected sensor update interval (e.g., \"S4 5000\") \nvar messageCode = msg.payload.content.split(\" \");\n\n// Save the selected interval\nnewSetting.interval = messageCode[1];\n\n// Update the chat context with the new setting\nchatContext.settingSimulationContext.newSetting = newSetting;\n\n// Prepare the final configuration summary\nvar input = newSetting;\n\nvar result = {\n    initialWeather: input.initialWeather,\n    fields: Object.entries(input.fields_configuration).map(([fieldId, sensors]) => ({\n        fieldId: parseInt(fieldId, 10), // Convert the key to a number\n        sensors: {\n            soilMoisture: sensors.soilMoisture,\n            temperature: sensors.temperature,\n            ph: sensors.soilPh, // Renamed from soilPh to ph\n            salinity: sensors.waterSalinity, // Renamed from waterSalinity to salinity\n            humidity: sensors.relativeHumidity, // Renamed from relativeHumidity to humidity\n            rain: sensors.rainfall // Renamed from rainfall to rain\n        }\n    })),\n    interval: parseInt(input.interval, 10)// Convert interval to an integer\n};\n\n\n// Create the confirmation message with a summary of the configuration\n//var newText = \"Excellent! \\r\\nThis is a summary of the configuration. ``` \\r\\n \" + JSON.stringify(result, null, 2) +  \"\\r\\n```  \\r\\nDo you want to confirm?\";\nvar newText = \"Excellent!\\r\\nThis is a summary of the configuration:<pre>\" + JSON.stringify(result, null, 2) + \"</pre>Do you want to confirm?\";\n\n// Define the inline keyboard for confirmation\nvar inline_keyboard = [\n    [\n        {\n            \"text\": \"Yes\",\n            \"callback_data\": \"S5\"\n        },\n        {\n            \"text\": \"NO\",\n            \"callback_data\": \"SCancel\"\n        }\n    ]\n];\n\n// Convert the inline keyboard to JSON format\nvar reply_markup = JSON.stringify({ \"inline_keyboard\": inline_keyboard });\n\nvar options = {\n    chat_id: msg.payload.chatId,\n    parse_mode: 'HTML', // Enable HTML formatting\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdSettings\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 2220,
        "wires": [
            [
                "7da069185bf6891a"
            ]
        ]
    },
    {
        "id": "3b1d37ce65c4a985",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Confirm, delete message, send MQTT json",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if the chat context or messageIdSettings exists\nif (!chatContext || !chatContext.messageIdSettings) {\n    node.error(\"Message ID not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Validate the simulation settings context\nif (!chatContext.settingSimulationContext || !chatContext.settingSimulationContext.newSetting || !Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field) || !Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field) || !Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field)) {\n    node.error(\"settingSimulationContext not found in Flow Context per chatId: \" + chatId);\n    node.error(\"!chatContext.settingSimulationContext: \" + !chatContext.settingSimulationContext);\n    node.error(\"!chatContext.settingSimulationContext.newSetting: \" + !chatContext.settingSimulationContext.newSetting);\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.total_field));\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.courrent_field));\n    node.error(\"!Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field): \" + !Number.isInteger(chatContext.settingSimulationContext.newSetting.next_field));\n    return null;\n}\n\n// Ensure fields_configuration exists when configuring more than one field\nif (!chatContext.settingSimulationContext.newSetting.fields_configuration && chatContext.settingSimulationContext.newSetting.total_field > 1 && chatContext.settingSimulationContext.newSetting.courrent_field > 1) {\n    node.error(\"fields_configuration not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Prepare confirmation message to send to the chat\nvar replyText = \"<strong>Configuration Saved</strong> and Sent to Server!\";\n\nvar sendTextMessage = {\n    payload: {\n        chatId: chatId,\n        type: 'message',\n        options: {\n            parse_mode: 'HTML'\n        },\n        content: replyText\n    }\n};\n\n// If there is a previous message to reply to, attach reply parameters\nif (chatContext.messageIdToReplaySettings) {\n    sendTextMessage.payload.options.reply_parameters = {\n        message_id: chatContext.messageIdToReplaySettings\n    };\n}\n\n// Prepare the payload to delete the previous inline keyboard message\nvar deleteInlineMessage = {\n    payload: {\n        chatId: chatId,\n        type: 'deleteMessage',\n        content: chatContext.messageIdSettings\n    }\n};\n\nvar newSetting = chatContext.settingSimulationContext.newSetting;\n\nvar input = newSetting;\n\n// Format the final configuration to be sent to the server\nvar result = {\n    initialWeather: input.initialWeather,\n    fields: Object.entries(input.fields_configuration).map(([fieldId, sensors]) => ({\n        fieldId: parseInt(fieldId, 10), // Convert the key to a number\n        sensors: {\n            soilMoisture: sensors.soilMoisture,\n            temperature: sensors.temperature,\n            ph: sensors.soilPh, // Renamed from soilPh to ph\n            salinity: sensors.waterSalinity, // Renamed from waterSalinity to salinity\n            humidity: sensors.relativeHumidity, // Renamed from relativeHumidity to humidity\n            rain: sensors.rainfall // Renamed from rainfall to rain\n        }\n    })),\n    interval: parseInt(input.interval, 10) // Convert interval to an integer\n};\n\n// Prepare the message to send the configuration to the server\nvar congifMessage = {\n    payload: result,\n    topic: 'sensors/simulation/config'\n}\n\n// Clean up stored chat context data\ndelete chatContext.settingSimulationContext;\ndelete chatContext.messageIdToReplaySettings;\ndelete chatContext.messageIdSettings;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\n// Return the three messages: \n// 1. Confirmation message to the chat\n// 2. Command to delete the inline keyboard message\n// 3. Configuration message to send to the server\nreturn [sendTextMessage, deleteInlineMessage, congifMessage];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 2280,
        "wires": [
            [
                "7da069185bf6891a",
                "20b3b83c60c12de1"
            ],
            [
                "7da069185bf6891a"
            ],
            [
                "a1bcd6bd9e3c2553",
                "2e829639469c3d9d"
            ]
        ]
    },
    {
        "id": "a1bcd6bd9e3c2553",
        "type": "mqtt out",
        "z": "bb32693f1e238fb3",
        "name": "",
        "topic": "sensors/simulation/config",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "24f8f90e89fb0dcc",
        "x": 1470,
        "y": 2100,
        "wires": []
    },
    {
        "id": "15566d22a530722b",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/current_configuration",
        "description": "Gets the current configuration of the sensor simulator",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 320,
        "y": 380,
        "wires": [
            [
                "2c71e861f8e05533",
                "caedbe9a15ad2ed7"
            ],
            []
        ]
    },
    {
        "id": "ba126469fe6188bd",
        "type": "mqtt out",
        "z": "bb32693f1e238fb3",
        "name": "",
        "topic": "sensors/simulation/config/get",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "24f8f90e89fb0dcc",
        "x": 860,
        "y": 380,
        "wires": []
    },
    {
        "id": "2c71e861f8e05533",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save idMessage",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Validate chatId: it must exist and be a number.\nif (!chatId || typeof chatId !== \"number\") {\n    node.error(\"Invalid chatId: \" + chatId);\n    return null;\n}\nvar chatContextKey = \"chat_\" + chatId;\nvar chatContext = flow.get(chatContextKey) || {}; // Retrieve stored chat context or initialize an empty object.\n\n// Store message ID related to the current configuration request.\nchatContext.messageIdCurrentConfig = msg.payload.messageId;\n\nflow.set(chatContextKey, chatContext); // Save updated chat context in the flow.\n\n// Debugging: Log chat context if internal debugging is enabled.\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: chatContextKey=\" + chatContextKey + \", content=\" + JSON.stringify(chatContext));\n}\n\n// Set the message payload to request the current configuration.\nmsg.payload = \"GET CURRENT CONFIGURATION\"\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 550,
        "y": 380,
        "wires": [
            [
                "ba126469fe6188bd"
            ]
        ]
    },
    {
        "id": "cdbff278454bf9c3",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "rispondi con current Configuration",
        "func": "// Get all keys from the flow context\nvar allKeys = flow.keys();\n\n// Filter only the keys that start with \"chat_\"\nvar chatKeys = allKeys.filter(key => key.startsWith(\"chat_\"));\n\n// Prepare an array for messages to be sent\nvar messages = [];\n\n// Iterate through all chat keys and check if they have messageIdCurrentConfig\nchatKeys.forEach(chatKey => {\n    var chatContext = flow.get(chatKey);\n\n    // Check if the \"messageIdCurrentConfig\" property exists\n    if (chatContext && chatContext.messageIdCurrentConfig) {\n        // Extract the chat ID from the key\n        var chatId = chatKey.replace(\"chat_\", \"\"); // Convert chat ID to an integer\n        messages.push({\n            chatId: parseInt(chatId, 10),\n            content: \"This is the current configuration of the simulation: <pre>\" + JSON.stringify(msg.payload, null, 2) + \"</pre>\",\n            type: \"message\",\n            options: {\n                parse_mode: \"HTML\",\n                reply_parameters: {\n                    message_id: chatContext.messageIdCurrentConfig // Reply to the specific message\n                }\n            },\n\n        });\n    }\n});\n\n// If there are messages to send, set them as an array in msg.payload\nif (messages.length > 0) {\n    var resp = {}\n    resp.payload = messages;\n    return resp; // Return the message for the next node\n} else {\n     // Debugging: Log a warning if no chat has messageIdCurrentConfig\n    if (global.get(\"internalDebug\")) {\n        node.warn(\"No chat with messageIdCurrentConfig found!\");\n    }\n    return null; // No messages to send\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 440,
        "wires": [
            [
                "7c5624cbfaf2871e"
            ]
        ]
    },
    {
        "id": "3e32583081d0b615",
        "type": "mqtt in",
        "z": "bb32693f1e238fb3",
        "name": "",
        "topic": "sensors/simulation/config/current",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "24f8f90e89fb0dcc",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 350,
        "y": 440,
        "wires": [
            [
                "cdbff278454bf9c3",
                "4694cfe12c3638e1"
            ]
        ]
    },
    {
        "id": "7c5624cbfaf2871e",
        "type": "split",
        "z": "bb32693f1e238fb3",
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "property": "payload",
        "x": 890,
        "y": 440,
        "wires": [
            [
                "a8dc04826bc75e23"
            ]
        ]
    },
    {
        "id": "a8dc04826bc75e23",
        "type": "change",
        "z": "bb32693f1e238fb3",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "payload",
                "tot": "msg",
                "dc": true
            },
            {
                "t": "delete",
                "p": "parts",
                "pt": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1040,
        "y": 440,
        "wires": [
            [
                "a651ef8769d332eb"
            ]
        ]
    },
    {
        "id": "a651ef8769d332eb",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1230,
        "y": 440,
        "wires": [
            [
                "811941ebe4c7febb"
            ]
        ]
    },
    {
        "id": "4694cfe12c3638e1",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Saves the current simulation configuration",
        "func": "var currentConfigKey = \"simulationConfiguration\";\n\n// Retrieve the current simulation configuration from global storage or initialize an empty object\nvar currentConfig = global.get(currentConfigKey) || {};\n\n// Update the configuration with the new payload\ncurrentConfig = msg.payload;\n\n// Save the updated configuration in global storage\nglobal.set(\"simulationConfiguration\", currentConfig);\n\n// Debugging: Log the saved configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Global: currentConfigKey=\" + currentConfigKey + \", content=\" + JSON.stringify(currentConfig));\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 500,
        "wires": [
            [
                "7a9b6ee89f80ec87"
            ]
        ]
    },
    {
        "id": "ea970c1f3fc66fa9",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/update_simulation_condition",
        "description": "Update the simulation condition",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 340,
        "y": 320,
        "wires": [
            [
                "13a3112f682e27db",
                "caedbe9a15ad2ed7",
                "149101f4987ee626"
            ],
            []
        ]
    },
    {
        "id": "13a3112f682e27db",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Keyboard UpdateCondition (Weather, interval, temperature, humidity) Step 0 ",
        "func": "// Define message options with an inline keyboard for user interaction.\nvar opts = {\n  reply_to_message_id: msg.payload.messageId, // Reply to the specific message ID.\n  reply_markup: JSON.stringify({\n    \"inline_keyboard\": [[\n      {\n        \"text\": \"Yes\", // Button labeled \"Yes\".\n        \"callback_data\": \"W0 YES\" // Data sent when the \"Yes\" button is pressed.\n      },\n      {\n        \"text\": \"No\", // Button labeled \"No\".\n        \"callback_data\": \"W0 NO\" // Data sent when the \"No\" button is pressed.\n      }]\n    ]\n  })\n};\n\n// Define the message content asking for user confirmation.\nmsg.payload.content = 'Are you sure you want to change the simulation conditions?';\n\n// Attach the options to the message payload.\nmsg.payload.options = opts;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 320,
        "wires": [
            [
                "6ab25b14acc24d5c"
            ]
        ]
    },
    {
        "id": "6ab25b14acc24d5c",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1170,
        "y": 320,
        "wires": [
            [
                "0478425b2bc2dea4"
            ]
        ]
    },
    {
        "id": "0478425b2bc2dea4",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save IdMessaggio messageIdUpdateCondition in ChatContex",
        "func": "var chatId = msg.payload.chatId;\n\n// Validate chatId: it must exist and be a number.\nif (!chatId || typeof chatId !== \"number\") {\n    node.error(\"Invalid chatId: \" + chatId);\n    return null;\n}\n\nvar chatContextKey = \"chat_\" + chatId;\nvar chatContext = flow.get(chatContextKey) || {}; // Retrieve stored chat context or initialize an empty object.\n\n// Store message IDs related to updating conditions.\nchatContext.messageIdToReplayUpdateCondition = msg.payload.messageId;\nchatContext.messageIdUpdateCondition = msg.payload.sentMessageId;\n\nflow.set(chatContextKey, chatContext); // Save updated chat context in the flow.\n\n// Debugging: Log chat context if internal debugging is enabled.\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: chatContextKey=\" + chatContextKey + \", content=\" + JSON.stringify(chatContext));\n}",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1540,
        "y": 320,
        "wires": []
    },
    {
        "id": "811941ebe4c7febb",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Delete messageIdCurrentConfig",
        "func": "// Get all keys from the flow context\nvar allKeys = flow.keys();\n\n// Filter only the keys that start with \"chat_\"\nvar chatKeys = allKeys.filter(key => key.startsWith(\"chat_\"));\n\n// Prepare an array for messages to be sent\nvar messages = [];\n\n// Iterate through all chat keys and check if they have messageIdCurrentConfig\nchatKeys.forEach(chatKey => {\n    var chatContext = flow.get(chatKey);\n\n    // Check if the \"messageIdCurrentConfig\" property exists\n    if (chatContext && chatContext.messageIdCurrentConfig) {\n        // Remove the property messageIdCurrentConfig\n        delete chatContext.messageIdCurrentConfig;\n\n        // Save the updated chat context back to the flow\n        flow.set(chatKey, chatContext);\n    }\n});\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 440,
        "wires": []
    },
    {
        "id": "dcd5787e50918357",
        "type": "switch",
        "z": "bb32693f1e238fb3",
        "name": "WCancel\\n W0 \\n W1\\n W2\\n W3\\n W4\\n W5\\n otherwise",
        "property": "payload.content",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "WCancel",
                "vt": "str"
            },
            {
                "t": "regex",
                "v": "^W0",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^W1",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^W2",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^W3",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^W4",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^W5",
                "vt": "str",
                "case": false
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 8,
        "x": 640,
        "y": 2460,
        "wires": [
            [
                "1bc4f96de1467796"
            ],
            [
                "dbf54bcb7d320d2e"
            ],
            [
                "18a2fd284157f87f"
            ],
            [
                "e81206999818d780"
            ],
            [
                "9a59d2a8666300df"
            ],
            [
                "33c1263aeb1a4a3b"
            ],
            [
                "1574fd2f535d0c2d"
            ],
            []
        ]
    },
    {
        "id": "94b59fc68cf6bccd",
        "type": "switch",
        "z": "bb32693f1e238fb3",
        "name": "S\\n W\\n A\\n T\\n otherwise",
        "property": "payload.content",
        "propertyType": "msg",
        "rules": [
            {
                "t": "regex",
                "v": "^S",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^W",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^A",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T",
                "vt": "str",
                "case": false
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 5,
        "x": 440,
        "y": 2000,
        "wires": [
            [
                "a2fe17dca5d86712"
            ],
            [
                "dcd5787e50918357"
            ],
            [
                "da8d85276f3785ff"
            ],
            [
                "b247f120d5335c41"
            ],
            []
        ]
    },
    {
        "id": "1bc4f96de1467796",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Abort UpdateCondition",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdUpdateCondition exists in the chat context\nif (!chatContext || !chatContext.messageIdUpdateCondition) {\n    node.error(\"Message ID (messageIdUpdateCondition) non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\n// Remove updateSimulationContext if it exists\nvar updateSimulationContext = chatContext.updateSimulationContext;\nif (chatContext.updateSimulationContext) {\n    delete chatContext.updateSimulationContext;\n}\n\n// Define the new response message\nvar newText = \"OK, you can reuse the /update_simulation_condition command when you are ready <strong>to change the simulation conditions</strong>!\";\n\n// Define an empty inline keyboard to remove any existing buttons\nvar reply_markup_empty = JSON.stringify({\n    \"inline_keyboard\": [] // Removes the inline keyboard if present\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup_empty,\n    message_id: chatContext.messageIdUpdateCondition,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Remove message-related properties from the chat context\ndelete chatContext.messageIdToReplayUpdateCondition;\ndelete chatContext.messageIdUpdateCondition;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 2380,
        "wires": [
            [
                "b58fcfa2f9d08c83",
                "20b3b83c60c12de1"
            ]
        ]
    },
    {
        "id": "b58fcfa2f9d08c83",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "sendTextMessage",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1450,
        "y": 2380,
        "wires": [
            []
        ]
    },
    {
        "id": "dbf54bcb7d320d2e",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Keyboard UpdateCondition Step 1",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdUpdateCondition exists in the chat context\nif (!chatContext || !chatContext.messageIdUpdateCondition) {\n    node.error(\"Message ID (messageIdUpdateCondition) non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the user's choice from the message payload\nvar userChoice = msg.payload.content; // Es. \"W0 YES\" o \"W1 NO\"\n\n// Prepare the new message content based on the user's choice\nvar newText;\nif (userChoice === \"W0 YES\") {\n    newText = \"Great, let's get started!!! \\r\\nWhat <strong>weather condition</strong> is present on the fields?\";\n} else if (userChoice === \"W0 NO\") {\n    newText = \"OK, you can reuse the /update_simulation_condition command when you are ready <strong>to change the simulation conditions</strong>!\";\n} else {\n    newText = \"Invalid choice!\";\n}\n\n// Prepare an empty inline keyboard to remove any existing buttons\nvar reply_markup_empty = JSON.stringify({\n    \"inline_keyboard\": [] // Removes the inline keyboard\n});\n\n// Prepare a new inline keyboard with weather condition options\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"‚òÄÔ∏è Sunny ‚òÄÔ∏è\",\n            \"callback_data\": \"W1 SUNNY\"\n        }],\n    [\n        {\n            \"text\": \"‚òÅÔ∏è Cloudy ‚òÅÔ∏è\",\n            \"callback_data\": \"W1 CLOUDY\"\n        }\n    ],\n    [\n        {\n            \"text\": \"üå¶Ô∏è Light Rain üå¶Ô∏è\",\n            \"callback_data\": \"W1 LIGHT_RAIN\"\n        }\n    ],\n    [\n        {\n            \"text\": \"üåßÔ∏è Moderate Rain üåßÔ∏è\",\n            \"callback_data\": \"W1 MODERATE_RAIN\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚õàÔ∏è Heavy Rain ‚õàÔ∏è\",\n            \"callback_data\": \"W1 HEAVY_RAIN\"\n        }\n    ],\n    [\n        {\n            \"text\": \"üåÄ Hurricane üåÄ\",\n            \"callback_data\": \"W1 HURRICANE\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"WCancel\"\n        }]\n    ]\n});\n\n// If the user selects \"YES,\" display the new keyboard with weather options\nif (userChoice === \"W0 YES\") {\n    var options = {\n        chat_id: msg.payload.chatId,\n        reply_markup: reply_markup,\n        message_id: chatContext.messageIdUpdateCondition,\n        parse_mode: 'HTML'\n    };\n    msg.payload.type = 'editMessageText';\n    msg.payload.content = newText;\n    msg.payload.options = options;\n} else {\n    // If the user selects \"NO,\" remove the inline keyboard\n    var options = {\n        chat_id: msg.payload.chatId,\n        reply_markup: reply_markup_empty,\n        message_id: chatContext.messageIdUpdateCondition,\n        parse_mode: 'HTML'\n    };\n    msg.payload.type = 'editMessageText';\n    msg.payload.content = newText;\n    msg.payload.options = options;\n\n    // Remove the message ID reference from the chat context\n    delete chatContext.messageIdUpdateCondition;\n    flow.set(chatContextKey, chatContext);\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 2420,
        "wires": [
            [
                "b58fcfa2f9d08c83"
            ]
        ]
    },
    {
        "id": "18a2fd284157f87f",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 1, present step 2 temperature",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdUpdateCondition exists in the chat context\nif (!chatContext || !chatContext.messageIdUpdateCondition) {\n    node.error(\"Message ID (messageIdUpdateCondition) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the current simulation configuration from the flow or set default values\nvar currentConfigKey = \"simulation_configuration\";\nvar currentConfig = flow.get(currentConfigKey) || {};\nvar updateSimulationContext = chatContext.updateSimulationContext || {};\n\n// Update the simulation context with weather and default values for interval, temperature, and humidity\nupdateSimulationContext = {\n    weather: msg.payload.content.split(\" \")[1],\n    interval: (typeof currentConfig.interval === 'number') ? currentConfig.interval : 5000, // default value\n    temperature: (typeof currentConfig.temperature === 'number') ? currentConfig.temperature : 24.5, // default value\n    humidity: (typeof currentConfig.humidity === 'number') ? currentConfig.humidity : 60.5 // default value\n};\n\n// Store the updated simulation context in the chat context\nchatContext.updateSimulationContext = updateSimulationContext;\n\n// Debugging: Log the stored simulation context if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateSimulationContext=\" + JSON.stringify(updateSimulationContext));\n}\n\n// Map the selected weather condition to a readable text\nvar weatherText;\n\nswitch (msg.payload.content) {\n    case \"W1 SUNNY\":\n        weatherText = \"‚òÄÔ∏è Sunny ‚òÄÔ∏è\";\n        break;\n    case \"W1 CLOUDY\":\n        weatherText = \"‚òÅÔ∏è Cloudy ‚òÅÔ∏è\";\n        break;\n    case \"W1 LIGHT_RAIN\":\n        weatherText = \"üå¶Ô∏è Light Rain üå¶Ô∏è\";\n        break;\n    case \"W1 MODERATE_RAIN\":\n        weatherText = \"üåßÔ∏è Moderate Rain üåßÔ∏è\";\n        break;\n    case \"W1 HEAVY_RAIN\":\n        weatherText = \"‚õàÔ∏è Heavy Rain ‚õàÔ∏è\";\n        break;\n    case \"W1 HURRICANE\":\n        weatherText = \"üåÄ Hurricane üåÄ\";\n        break;\n    default:\n        weatherText = \"Unknown\";\n}\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>weather</strong> is <strong>\" + weatherText + \"</strong> !\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what <strong>outside temperature</strong> we have on agricultural fields!\";\n\n// Define the inline keyboard for temperature selection\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"24.5¬∞C (Deafult Temperature)\",\n            \"callback_data\": \"W2 24.50\"\n        }],\n    [\n        {\n            \"text\": \"-10¬∞C\",\n            \"callback_data\": \"W2 -10.01\"\n        },\n        {\n            \"text\": \"-5¬∞C\",\n            \"callback_data\": \"W2 -5.01\"\n        },\n        {\n            \"text\": \"0¬∞C\",\n            \"callback_data\": \"W2 0.01\"\n        },\n        {\n            \"text\": \"5¬∞C\",\n            \"callback_data\": \"W2 5.01\"\n        }\n    ],\n    [\n        {\n            \"text\": \"10¬∞C\",\n            \"callback_data\": \"W2 10.01\"\n        },\n        {\n            \"text\": \"15¬∞C\",\n            \"callback_data\": \"W2 15.01\"\n        },\n        {\n            \"text\": \"20¬∞C\",\n            \"callback_data\": \"W2 20.01\"\n        },\n        {\n            \"text\": \"25¬∞C\",\n            \"callback_data\": \"W2 25.01\"\n        }\n    ],\n    [\n        {\n            \"text\": \"30¬∞C\",\n            \"callback_data\": \"W2 30.01\"\n        },\n        {\n            \"text\": \"35¬∞C\",\n            \"callback_data\": \"W2 35.01\"\n        },\n        {\n            \"text\": \"40¬∞C\",\n            \"callback_data\": \"W2 40.01\"\n        },\n        {\n            \"text\": \"45¬∞C\",\n            \"callback_data\": \"W2 45.01\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"WCancel\"\n        }]\n    ]\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdUpdateCondition,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 2460,
        "wires": [
            [
                "b58fcfa2f9d08c83"
            ]
        ]
    },
    {
        "id": "e81206999818d780",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 2, present step 3 humidity",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdUpdateCondition exists in the chat context\nif (!chatContext || !chatContext.messageIdUpdateCondition) {\n    node.error(\"Message ID (messageIdUpdateCondition) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the simulation update context\nvar updateSimulationContext = chatContext.updateSimulationContext;\n\n// Check if updateSimulationContext exists\nif (!updateSimulationContext) {\n    node.error(\"updateSimulationContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the temperature value in the simulation context\nupdateSimulationContext.temperature = parseFloat(msg.payload.content.split(\" \")[1]);\n\n// Store the updated simulation context in the chat context\nchatContext.updateSimulationContext = updateSimulationContext;\n\n// Debugging: Log the stored simulation context if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Salvato nel Flow: updateSimulationContext=\" + JSON.stringify(updateSimulationContext));\n}\n\n// Extract the selected temperature value\nvar weatherText = msg.payload.content.split(\" \")[1];\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>temperature</strong> is <strong>\" + weatherText + \"¬∞C</strong>!\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what is the <strong>external Humidity</strong> we have on agricultural fields!\";\n\n// Define the inline keyboard for humidity selection\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"60.5% (Deafult Humidity)\",\n            \"callback_data\": \"W3 60.5\"\n        }],\n    [\n        {\n            \"text\": \"0%\",\n            \"callback_data\": \"W3 0.01\"\n        },\n        {\n            \"text\": \"10%\",\n            \"callback_data\": \"W3 10.01\"\n        },\n        {\n            \"text\": \"20%\",\n            \"callback_data\": \"W3 20.01\"\n        },\n        {\n            \"text\": \"30%\",\n            \"callback_data\": \"W3 30.01\"\n        }\n    ],\n    [\n        {\n            \"text\": \"40%\",\n            \"callback_data\": \"W3 40.01\"\n        },\n        {\n            \"text\": \"45%\",\n            \"callback_data\": \"W3 45.01\"\n        },\n        {\n            \"text\": \"50%\",\n            \"callback_data\": \"W3 50.01\"\n        },\n        {\n            \"text\": \"55%\",\n            \"callback_data\": \"W3 55.01\"\n        }\n    ],\n    [\n        {\n            \"text\": \"60%\",\n            \"callback_data\": \"W3 60.01\"\n        },\n        {\n            \"text\": \"70%\",\n            \"callback_data\": \"W3 70.01\"\n        },\n        {\n            \"text\": \"80%\",\n            \"callback_data\": \"W3 80.01\"\n        },\n        {\n            \"text\": \"90%\",\n            \"callback_data\": \"W3 90.01\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"WCancel\"\n        }]\n    ]\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdUpdateCondition,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 2500,
        "wires": [
            [
                "b58fcfa2f9d08c83"
            ]
        ]
    },
    {
        "id": "9a59d2a8666300df",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 3, present step 4 Interval",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdUpdateCondition exists in the chat context\nif (!chatContext || !chatContext.messageIdUpdateCondition) {\n    node.error(\"Message ID (messageIdUpdateCondition) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the simulation update context\nvar updateSimulationContext = chatContext.updateSimulationContext;\n\n// Check if updateSimulationContext exists\nif (!updateSimulationContext) {\n    node.error(\"updateSimulationContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the temperature value in the simulation context\nupdateSimulationContext.humidity = parseFloat(msg.payload.content.split(\" \")[1]);\n\n// Store the updated simulation context in the chat context\nchatContext.updateSimulationContext = updateSimulationContext;\n\n// Debugging: Log the stored simulation context if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Salvato nel Flow: updateSimulationContext=\" + JSON.stringify(updateSimulationContext));\n}\n\n// Extract the selected temperature value\nvar weatherText = msg.payload.content.split(\" \")[1];\n\nvar newText = \"OK, the current <strong>humidity</strong> is <strong>\" + weatherText + \"%</strong>!\\r\\nExcellent! \\r\\nNow all that remains is to determine how often the sensors will update. \\r\\n\\r\\nSelect the <strong>time interval</strong> from those present:\";\n\n// Define the inline keyboard for humidity selection\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [\n        [\n            {\n                \"text\": \"DEFAULT 5 sec\",\n                \"callback_data\": \"W4 5000\"\n            }\n        ],\n        [\n            {\n                \"text\": \"1 sec\",\n                \"callback_data\": \"W4 1000\"\n            },\n            {\n                \"text\": \"2 sec\",\n                \"callback_data\": \"W4 2000\"\n            }\n        ],\n        [\n            {\n                \"text\": \"10 sec\",\n                \"callback_data\": \"W4 10000\"\n            },\n            {\n                \"text\": \"15 sec\",\n                \"callback_data\": \"W4 15000\"\n            }\n        ],\n        [\n            {\n                \"text\": \"30 sec\",\n                \"callback_data\": \"W4 30000\"\n            },\n            {\n                \"text\": \"1 min\",\n                \"callback_data\": \"W4 60000\"\n            }\n        ],\n        [\n            {\n                \"text\": \"‚ùå   ABORT   ‚ùå\",\n                \"callback_data\": \"WCancel\"\n            }\n        ]\n    ]\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdUpdateCondition,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 2540,
        "wires": [
            [
                "b58fcfa2f9d08c83"
            ]
        ]
    },
    {
        "id": "33c1263aeb1a4a3b",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 4, peresent the summary",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdUpdateCondition exists in the chat context\nif (!chatContext || !chatContext.messageIdUpdateCondition) {\n    node.error(\"Message ID (messageIdUpdateCondition) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the simulation update context\nvar updateSimulationContext = chatContext.updateSimulationContext;\n\n// Check if updateSimulationContext exists\nif (!updateSimulationContext) {\n    node.error(\"updateSimulationContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the interval value in the simulation context\nupdateSimulationContext.interval = parseInt(msg.payload.content.split(\" \")[1]);\n\n// Store the updated simulation context in the chat context\nchatContext.updateSimulationContext = updateSimulationContext;\n\n// Debugging: Log the stored simulation context if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateSimulationContext=\" + JSON.stringify(updateSimulationContext));\n}\n\n// Extract the selected interval value and convert it into human-readable text\nvar weatherText = msg.payload.content.split(\" \")[1];\n\nswitch (msg.payload.content) {\n    case \"W4 5000\":\n        weatherText = \"5 sec\";\n        break;\n    case \"W4 1000\":\n        weatherText = \"1 sec\";\n        break;\n    case \"W4 2000\":\n        weatherText = \"2 sec\";\n        break;\n    case \"W4 10000\":\n        weatherText = \"10 sec\";\n        break;\n    case \"W4 15000\":\n        weatherText = \"15 sec\";\n        break;\n    case \"W4 30000\":\n        weatherText = \"30 sec\";\n        break;\n    case \"W4 60000\":\n        weatherText = \"1 min\";\n        break;\n    default:\n        weatherText = \"Unknown\";\n}\n\n// Prepare the response message with a summary of the configuration\nvar newText = \"OK, the current <strong>interval</strong> is <strong>\" + weatherText + \" </strong>!\\r\\n<strong>Excellent!</strong>\\r\\n\\r\\n This is a summary of the configuration:<pre>\" + JSON.stringify(updateSimulationContext, null, 2) + \"</pre>\\r\\n\\r\\nDo you want to <strong>confirm</strong>?\";\n\n// Define the inline keyboard for confirmation\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [\n        [\n            {\n                \"text\": \"YES\",\n                \"callback_data\": \"W5 YES\"\n            },\n            {\n                \"text\": \"NO\",\n                \"callback_data\": \"WCancel\"\n            }\n        ]\n    ]\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    parse_mode: 'HTML',\n    message_id: chatContext.messageIdUpdateCondition\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 2580,
        "wires": [
            [
                "b58fcfa2f9d08c83"
            ]
        ]
    },
    {
        "id": "1574fd2f535d0c2d",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Confirm, delete message, send MQTT json",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdUpdateCondition exists in the chat context\nif (!chatContext || !chatContext.messageIdUpdateCondition) {\n    node.error(\"messageIdUpdateCondition ID not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Create a copy of the updateSimulationContext objectv\nvar updateSimulationContext = { ...chatContext.updateSimulationContext }; // Copia dell'oggetto\n\n// Validate the updateSimulationContext object\nif (!updateSimulationContext || !updateSimulationContext.weather || !Number.isInteger(updateSimulationContext.interval) || !(Number(updateSimulationContext.temperature) === updateSimulationContext.temperature && !Number.isInteger(updateSimulationContext.temperature)) || !(Number(updateSimulationContext.humidity) === updateSimulationContext.humidity && !Number.isInteger(updateSimulationContext.humidity))) {\n    node.error(\"updateSimulationContext non trovato nel Flow Context per chatId: \" + chatId);\n    node.error(\"!updateSimulationContext.weather: \" + !updateSimulationContext.weather);\n    node.error(\"!Number.isInteger(updateSimulationContext.interval): \" + !Number.isInteger(updateSimulationContext.interval));\n    node.error(\"!(Number(updateSimulationContext.temperature) === updateSimulationContext.temperature && !Number.isInteger(updateSimulationContext.temperature)): \" + !(Number(updateSimulationContext.temperature) === updateSimulationContext.temperature && !Number.isInteger(updateSimulationContext.temperature)));\n    node.error(\"!(Number(updateSimulationContext.humidity) === updateSimulationContext.humidity && !Number.isInteger(updateSimulationContext.humidity)): \" + !(Number(updateSimulationContext.humidity) === updateSimulationContext.humidity && !Number.isInteger(updateSimulationContext.humidity)));\n    return null;\n}\n\n// Prepare the confirmation message for the chat\nvar replyText = \"<strong>Simulation conditions</strong> saved and sent to the server <strong>Successfully</strong>!\";\n\nvar sendTextMessage = {\n    payload: {\n        chatId: chatId,\n        type: 'message',\n        options: {\n            parse_mode: 'HTML'\n        },\n        content: replyText\n    }\n};\n\n// If there is a previous message to reply to, attach reply parameters\nif (chatContext.messageIdToReplayUpdateCondition) {\n    sendTextMessage.payload.options.reply_parameters = {\n        message_id: chatContext.messageIdToReplayUpdateCondition\n    };\n}\n\n// Prepare the payload to delete the previous inline keyboard message\nvar deleteInlineMessage = {\n    payload: {\n        chatId: chatId,\n        type: 'deleteMessage',\n        content: chatContext.messageIdUpdateCondition\n    }\n};\n\n// Format the final configuration to be sent to the server\nvar result = {\n    weather: updateSimulationContext.weather,\n    interval: parseInt(updateSimulationContext.interval, 10),\n    temperature: parseFloat(updateSimulationContext.temperature),\n    humidity: parseFloat(updateSimulationContext.humidity)\n};\n\n// Clean up stored chat context data\ndelete chatContext.updateSimulationContext;\ndelete chatContext.messageIdToReplayUpdateCondition;\ndelete chatContext.messageIdUpdateCondition;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\n// Prepare the message to send the updated simulation conditions to the server\nvar congifMessage = {\n    payload: result,\n    topic: 'sensors/simulation/update'\n}\n\n// Return three messages: \n// 1. Confirmation message to the chat\n// 2. Command to delete the inline keyboard message\n// 3. Updated simulation conditions message to send to the server\nreturn [sendTextMessage, deleteInlineMessage, congifMessage];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 2640,
        "wires": [
            [
                "b58fcfa2f9d08c83",
                "20b3b83c60c12de1"
            ],
            [
                "b58fcfa2f9d08c83"
            ],
            [
                "5bd2940289498b55",
                "1d4fa3ebecd6de4c"
            ]
        ]
    },
    {
        "id": "5bd2940289498b55",
        "type": "mqtt out",
        "z": "bb32693f1e238fb3",
        "name": "",
        "topic": "sensors/simulation/update",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "24f8f90e89fb0dcc",
        "x": 1470,
        "y": 2440,
        "wires": []
    },
    {
        "id": "12c9d4086aa931e7",
        "type": "inject",
        "z": "bb32693f1e238fb3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": false,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 310,
        "y": 60,
        "wires": [
            [
                "d4a7c59e69d97b71"
            ]
        ]
    },
    {
        "id": "d4a7c59e69d97b71",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Garbage Collector",
        "func": "// Get all keys from the flow context\nvar contextKeys = flow.keys(); // Specify the 'file' store, or 'memory' if necessary\n\n// Count of removed objects\nvar removedCount = 0;\n\n// Iterate over all keys\ncontextKeys.forEach(function(key) {\n    // Retrieve the value associated with the key\n    var value = flow.get(key, \"file\"); // Specify the appropriate store\n\n    // Check if the value is an empty object\n    if (value && typeof value === \"object\" && Object.keys(value).length === 0) {\n        // Remove the key from the context\n        flow.set(key, undefined);\n        removedCount++;\n        node.warn(\"Removed empty object: \" + key);\n    }\n});\n\n// Final debug (commented out)\n// node.warn(\"Cleanup complete. Empty objects removed: \" + removedCount);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "48070c787a2a837f",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/toggle_alert",
        "description": "Enable or disable the reception of alerts.",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 290,
        "y": 580,
        "wires": [
            [
                "d989cee4de450ddf",
                "caedbe9a15ad2ed7",
                "149101f4987ee626"
            ],
            []
        ]
    },
    {
        "id": "d989cee4de450ddf",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "/toggle_alert",
        "func": "// Define the help message asking the user if they want to activate alerts\nvar helpMessage = \"Do you want to activate alerts?\";\n\n// Define message options with an inline keyboard for user interaction\nvar opts = {\n  reply_to_message_id: msg.payload.messageId, // Reply to the specific message ID\n  reply_markup: JSON.stringify({\n    \"inline_keyboard\": [[\n      {\n        \"text\": \"Yes\", // Button labeled \"Yes\"\n        \"callback_data\": \"A YES\" // Data sent when the \"Yes\" button is pressed\n      },\n      {\n        \"text\": \"No\", // Button labeled \"No\"\n        \"callback_data\": \"A NO\" // Data sent when the \"No\" button is pressed\n      }]\n    ]\n  })\n};\n\n// Set the message content\nmsg.payload.content = helpMessage;\n\n// Attach the options to the message payload\nmsg.payload.options = opts;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 580,
        "wires": [
            [
                "8ace769ee009b9aa"
            ]
        ]
    },
    {
        "id": "8ace769ee009b9aa",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 670,
        "y": 580,
        "wires": [
            [
                "8f98493fc538890a"
            ]
        ]
    },
    {
        "id": "8f98493fc538890a",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save IdMessaggio messageIdToggleAllert in ChatContex",
        "func": "var chatId = msg.payload.chatId;\n\n// Validate chatId: it must exist and be a number\nif (!chatId || typeof chatId !== \"number\") {\n    node.error(\"chatId non valido: \" + chatId);\n    return null;\n}\n\n// Save the message\nvar chatContextKey = \"chat_\" + chatId;\nvar chatContext = flow.get(chatContextKey) || {}; // Retrieve stored chat context or initialize an empty object\n\n// Store message IDs related to toggling alerts\nchatContext.messageIdToReplayToggleAllert = msg.payload.messageId; // Save updated chat context in the flow\nchatContext.messageIdToggleAllert = msg.payload.sentMessageId;\n\nflow.set(chatContextKey, chatContext);\n\n// Debugging: Log chat context if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: chatContextKey=\" + chatContextKey + \", content=\" + JSON.stringify(chatContext));\n}",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 580,
        "wires": []
    },
    {
        "id": "da8d85276f3785ff",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save your choice of Allert toggle",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdToggleAllert exists in the chat context\nif (!chatContext || !chatContext.messageIdToggleAllert) {\n    node.error(\"messageIdToggleAllert ID not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Save the user's choice\nconst storedChats = global.get('chats') || [];\nconst chats = new Map(storedChats);\n//chats.set(chatContextKey, msg.payload.content.split(\" \")[1] == \"YES\");\n\n// Create a settings object and set the alert status based on the user's choice\nconst settings = {};\nsettings.active = msg.payload.content.split(\" \")[1] == \"YES\";\nif (chats.has(chatContextKey)) {\n    const existingData = chats.get(chatContextKey);\n    // Preserve the email if it already exists in the chat settings\n    if (existingData.email) {\n        settings.email = existingData.email;\n    }\n}\n\n// Update chat settings with the new alert status\nchats.set(chatContextKey, settings); \n\n// Prepare the confirmation message based on the user's choice\nvar replyText = msg.payload.content.split(\" \")[1] == \"YES\" ? \"Alerts have been *activated* for this chat\\\\!\" : \"Alerts have been *deactivated* for this chat\\\\!\";\n\n// Construct the message payload to notify the user\nvar sendTextMessage = {\n    payload: {\n        chatId: chatId,\n        type: 'message',\n        options: {\n            parse_mode: 'MarkdownV2' // Enable MarkdownV2 formatting\n        },\n        content: replyText\n    }\n};\n\n// If there is a previous message to reply to, attach reply parameters\nif (chatContext.messageIdToReplayToggleAllert) {\n    sendTextMessage.payload.options.reply_parameters = {\n        message_id: chatContext.messageIdToReplayToggleAllert\n    };\n}\n\n// Prepare the payload to delete the previous inline keyboard message\nvar deleteInlineMessage = {\n    payload: {\n        chatId: chatId,\n        type: 'deleteMessage',\n        content: chatContext.messageIdToggleAllert\n    }\n};\n\n// Remove message-related properties from the chat context\ndelete chatContext.messageIdToReplayToggleAllert;\ndelete chatContext.messageIdToggleAllert;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\n// Save the updated chat settings globally\nglobal.set('chats', Array.from(chats.entries()));\n\n// Return two messages: \n// 1. Confirmation message to the chat\n// 2. Command to delete the inline keyboard message\nreturn [sendTextMessage, deleteInlineMessage];",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 2720,
        "wires": [
            [
                "51ec93ced4a852c2",
                "20b3b83c60c12de1"
            ],
            [
                "51ec93ced4a852c2"
            ]
        ]
    },
    {
        "id": "51ec93ced4a852c2",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "sendTextMessage",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1470,
        "y": 2720,
        "wires": [
            []
        ]
    },
    {
        "id": "b247f120d5335c41",
        "type": "switch",
        "z": "bb32693f1e238fb3",
        "name": "TCancel\\n T10\\n T11\\n T12\\n T0\\n T1\\n T2\\n T3\\n T4\\n T5\\n T6\\n T7\\n T8\\n T9\\n  otherwise",
        "property": "payload.content",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "TCancel",
                "vt": "str"
            },
            {
                "t": "regex",
                "v": "^T10",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T11",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T12",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T0",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T1",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T2",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T3",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T4",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T5",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T6",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T7",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T8",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "^T9",
                "vt": "str",
                "case": false
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 15,
        "x": 640,
        "y": 2980,
        "wires": [
            [
                "ec1d620b3538640c"
            ],
            [
                "140d1cef39a69e71"
            ],
            [
                "01373f6a28222ac6"
            ],
            [
                "122668a4219d7510"
            ],
            [
                "e1b82e9f3ce1210d"
            ],
            [
                "32160f31f502995f"
            ],
            [
                "2ecd231db192d564"
            ],
            [
                "293beffcfe631193"
            ],
            [
                "76f9aef93b813e69"
            ],
            [
                "7b154a32a9946a78"
            ],
            [
                "c248b16deb8c4683"
            ],
            [
                "76f709bd1353ac86"
            ],
            [
                "2c2dc52b79ba2099"
            ],
            [
                "34422461f7222e04"
            ],
            []
        ]
    },
    {
        "id": "ec1d620b3538640c",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Abort Change thresholds",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Remove the updateSimulationContext if it exists\nvar updateSimulationContext = chatContext.updateSimulationContext;\nif (chatContext.updateSimulationContext) {\n    delete chatContext.updateSimulationContext;\n}\n\n// Prepare the response message\nvar newText = \"OK, you can reuse the /change_thresholds command when you are <stron>ready to change thresholds for simulation alerts</stron>!\";\n\n// Define an empty inline keyboard to remove any existing buttons\nvar reply_markup_empty = JSON.stringify({\n    \"inline_keyboard\": [] // Removes the inline keyboard if present\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup_empty,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Remove message-related properties from the chat context\ndelete chatContext.messageIdChangeThresholds;\ndelete chatContext.updateThresholdsContext;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 2760,
        "wires": [
            [
                "879783e120251e28",
                "20b3b83c60c12de1"
            ]
        ]
    },
    {
        "id": "879783e120251e28",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "sendTextMessage",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1470,
        "y": 3000,
        "wires": [
            []
        ]
    },
    {
        "id": "c43039340ae1fab1",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/change_thresholds",
        "description": "Update the thresholds for alert",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 310,
        "y": 700,
        "wires": [
            [
                "dcbf42301d581e1a",
                "caedbe9a15ad2ed7",
                "149101f4987ee626"
            ],
            []
        ]
    },
    {
        "id": "dcbf42301d581e1a",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Keyboard Change thresholds Step 0 ",
        "func": "// Define message options with an inline keyboard for user interaction\nvar opts = {\n    reply_to_message_id: msg.payload.messageId, // Reply to the specific message ID\n    reply_markup: JSON.stringify({\n        \"inline_keyboard\": [[\n            {\n                \"text\": \"Yes\", // Button labeled \"Yes\"\n                \"callback_data\": \"T0 YES\" // Data sent when the \"Yes\" button is pressed\n            },\n            {\n                \"text\": \"No\", // Button labeled \"No\"\n                \"callback_data\": \"T0 NO\" // Data sent when the \"No\" button is pressed\n            }]\n        ]\n    })\n};\n\n// Set the message content asking for user confirmation\nmsg.payload.content = 'Are you sure you want to change the thresholds for simulation alerts?';\n\n// Attach the options to the message payload\nmsg.payload.options = opts;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 700,
        "wires": [
            [
                "ae347043c2f82ba3"
            ]
        ]
    },
    {
        "id": "ae347043c2f82ba3",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 870,
        "y": 700,
        "wires": [
            [
                "5db7aeda46fb9706"
            ]
        ]
    },
    {
        "id": "5db7aeda46fb9706",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save IdMessaggio messageIdChangeThresholds in ChatContex",
        "func": "var chatId = msg.payload.chatId;\n\n// Validate chatId: it must exist and be a number\nif (!chatId || typeof chatId !== \"number\") {\n    node.error(\"chatId non valido: \" + chatId);\n    return null;\n}\n\nvar chatContextKey = \"chat_\" + chatId;\nvar chatContext = flow.get(chatContextKey) || {}; // Retrieve stored chat context or initialize an empty object\n\n// Store message IDs related to changing thresholds\nchatContext.messageIdToReplayChangeThresholds = msg.payload.messageId;\nchatContext.messageIdChangeThresholds = msg.payload.sentMessageId;\n\n\nflow.set(chatContextKey, chatContext); // Save updated chat context in the flow\n\n// Debugging: Log chat context if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Salvato nel Flow: chatContextKey=\" + chatContextKey + \", contenuto=\" + JSON.stringify(chatContext));\n}\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1210,
        "y": 700,
        "wires": []
    },
    {
        "id": "e1b82e9f3ce1210d",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Keyboard Change thresholds Step 1",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) non trovato nel Flow Context per chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the user's choice from the message payload\nvar userChoice = msg.payload.content; // Example: \"T0 YES\" or \"T0 NO\"\n\n// Prepare the new message content based on the user's choice\nvar newText;\nif (userChoice === \"T0 YES\") {\n    newText = \"\\r\\nGreat, let's get started!!! \\r\\n\\r\\nWhat is the <strong>minimum threshold</strong> value for <strong>Soil Moisture</strong> sensors?\";\n} else if (userChoice === \"T0 NO\") {\n    newText = \"OK, you can reuse the /change_thresholds command when you are <stron>ready to change thresholds for simulation alerts</stron>!\";\n} else {\n    newText = \"Invalid choice!\";\n}\n\n// Define an empty inline keyboard to remove any existing buttons\nvar reply_markup_empty = JSON.stringify({\n    \"inline_keyboard\": [] // Removes the inline keyboard\n});\n\n// Define the inline keyboard for threshold selection\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MIN: 20%\",\n            \"callback_data\": \"T1 20\"\n        }],\n    [\n        {\n            \"text\": \"5%\",\n            \"callback_data\": \"T1 5\"\n        },\n        {\n            \"text\": \"10%\",\n            \"callback_data\": \"T1 10\"\n        },\n        {\n            \"text\": \"15%\",\n            \"callback_data\": \"T1 15\"\n        }\n    ],\n    [\n        {\n            \"text\": \"20%\",\n            \"callback_data\": \"T1 20\"\n        },\n        {\n            \"text\": \"25%\",\n            \"callback_data\": \"T1 25\"\n        },\n        {\n            \"text\": \"30%\",\n            \"callback_data\": \"T1 30\"\n        }\n    ],\n    [\n        {\n            \"text\": \"35%\",\n            \"callback_data\": \"T1 35\"\n        },\n        {\n            \"text\": \"40%\",\n            \"callback_data\": \"T1 40\"\n        },\n        {\n            \"text\": \"45%\",\n            \"callback_data\": \"T1 45\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\n// If the user selects \"YES,\" display the new keyboard with threshold options\nif (userChoice === \"T0 YES\") {\n    var options = {\n        chat_id: msg.payload.chatId,\n        reply_markup: reply_markup,\n        message_id: chatContext.messageIdChangeThresholds,\n        parse_mode: 'HTML'\n    };\n    msg.payload.type = 'editMessageText';\n    msg.payload.content = newText;\n    msg.payload.options = options;\n} else {\n    // If the user selects \"NO,\" remove the inline keyboard\n    var options = {\n        chat_id: msg.payload.chatId,\n        reply_markup: reply_markup_empty,\n        message_id: chatContext.messageIdChangeThresholds,\n        parse_mode: 'HTML'\n    };\n    msg.payload.type = 'editMessageText';\n    msg.payload.content = newText;\n    msg.payload.options = options;\n\n    // Remove the message ID reference from the chat context\n    delete chatContext.messageIdChangeThresholds;\n    flow.set(chatContextKey, chatContext);\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 2800,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "32160f31f502995f",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 1, present step 2 ",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the current threshold configuration from the flow or set default values\nvar currentConfigKey = \"thresholds_configuration\";\nvar currentConfig = flow.get(currentConfigKey) || {};\n\n// Retrieve or initialize the updateThresholdsContext object\nvar updateThresholdsContext = chatContext.updateThresholdsContext || {};\n\n// Update the threshold values with the selected minimum soil moisture threshold\nupdateThresholdsContext = {\n    soilMoisture: { min: parseInt(msg.payload.content.split(\" \")[1], 10), max: 80 },\n    temperature: { min: 0, max: 35 }, // default value\n    ph: { min: 5.5, max: 7.5 }, // default value\n    salinity: { min: 200, max: 1500 }, // default value\n    humidity: { min: 30, max: 90 }, // default value\n    rain: { max: 50 } // default value\n};\n\n// Store the updated threshold configuration in the chat context\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Debugging: Log the stored threshold configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Salvato nel Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\nvar weatherText;\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>Minimum Threshold</strong> value for <strong>Soil Moisture</strong> sensors is <strong>\" + msg.payload.content.split(\" \")[1] + \"%</strong>! Great! \\r\\n\\r\\nNow we have to decide what will be the <strong>Maximum Threshold</strong> value for the <strong>Soil Moisture</strong> sensors!\";\n\n// Define the inline keyboard for selecting the maximum threshold\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MAX: 80%\",\n            \"callback_data\": \"T2 80\"\n        }],\n    [\n        {\n            \"text\": \"50%\",\n            \"callback_data\": \"T2 50\"\n        },\n        {\n            \"text\": \"55%\",\n            \"callback_data\": \"T2 55\"\n        },\n        {\n            \"text\": \"60%\",\n            \"callback_data\": \"T2 60\"\n        }\n    ],\n    [\n        {\n            \"text\": \"65%\",\n            \"callback_data\": \"T2 65\"\n        },\n        {\n            \"text\": \"70%\",\n            \"callback_data\": \"T2 70\"\n        },\n        {\n            \"text\": \"75%\",\n            \"callback_data\": \"T2 75\"\n        }\n    ],\n    [\n        {\n            \"text\": \"80%\",\n            \"callback_data\": \"T2 80\"\n        },\n        {\n            \"text\": \"85%\",\n            \"callback_data\": \"T2 85\"\n        },\n        {\n            \"text\": \"90%\",\n            \"callback_data\": \"T2 90\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 2840,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "2ecd231db192d564",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 2, present step 3",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the updateThresholdsContext\nvar updateThresholdsContext = chatContext.updateThresholdsContext;\n\n// Check if updateThresholdsContext exists\nif (!updateThresholdsContext) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the maximum threshold for Soil Moisture sensors\nupdateThresholdsContext.soilMoisture.max = parseInt(msg.payload.content.split(\" \")[1], 10);\n\n// Store the updated threshold configuration in the chat context\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Debugging: Log the stored threshold configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>Maximum Threshold</strong> value for <strong>Soil Moisture</strong> sensors is <strong>\" + msg.payload.content.split(\" \")[1] + \"%</strong>!\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what will be the <strong>Minimum Threshold</strong> value for the <strong>Temperature</strong> sensors!\";\n\n// Define the inline keyboard for selecting the minimum threshold for Temperature sensors\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MIN: 0¬∞C\",\n            \"callback_data\": \"T3 0\"\n        }],\n    [\n        {\n            \"text\": \"-5¬∞C\",\n            \"callback_data\": \"T3 -5\"\n        },\n        {\n            \"text\": \"0¬∞C\",\n            \"callback_data\": \"T3 0\"\n        }\n    ],\n    [\n        {\n            \"text\": \"5¬∞C\",\n            \"callback_data\": \"T3 5\"\n        },\n        {\n            \"text\": \"10¬∞C\",\n            \"callback_data\": \"T3 10\"\n        }\n    ],\n    [\n        {\n            \"text\": \"15¬∞C\",\n            \"callback_data\": \"T3 15\"\n        },\n        {\n            \"text\": \"20¬∞C\",\n            \"callback_data\": \"T3 20\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 2880,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "293beffcfe631193",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 3, present step 4",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve chat context from the flow\nvar updateThresholdsContext = chatContext.updateThresholdsContext;\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!updateThresholdsContext) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the updateThresholdsContext\nupdateThresholdsContext.temperature.min = parseInt(msg.payload.content.split(\" \")[1], 10);\n\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Check if updateThresholdsContext exists\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Salvato nel Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\n\nvar newText = \"OK, the current <strong>Minimum Threshold</strong> value for <strong>Temperature</strong> sensors is <strong>\" + msg.payload.content.split(\" \")[1] + \"¬∞C</strong>!\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what will be the <strong>Maximum Threshold</strong> value for the <strong>Temperature</strong> sensors!\";\n\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MAX: 35¬∞C\",\n            \"callback_data\": \"T4 35\"\n        }],\n    [\n        {\n            \"text\": \"25¬∞C\",\n            \"callback_data\": \"T4 25\"\n        },\n        {\n            \"text\": \"30¬∞C\",\n            \"callback_data\": \"T4 30\"\n        }\n    ],\n    [\n        {\n            \"text\": \"35¬∞C\",\n            \"callback_data\": \"T4 35\"\n        },\n        {\n            \"text\": \"40¬∞C\",\n            \"callback_data\": \"T4 40\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 2920,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "76f9aef93b813e69",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 4, present step 5",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the updateThresholdsContext\nvar updateThresholdsContext = chatContext.updateThresholdsContext;\n\n// Check if updateThresholdsContext exists\nif (!updateThresholdsContext) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the maximum threshold for Temperature sensors\nupdateThresholdsContext.temperature.max = parseInt(msg.payload.content.split(\" \")[1], 10);\n\n// Store the updated threshold configuration in the chat context\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Debugging: Log the stored threshold configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>Maximum Threshold</strong> value for <strong>Temperature</strong> sensors is <strong>\" + msg.payload.content.split(\" \")[1] + \"¬∞C</strong>!\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what will be the <strong>Minimum Threshold</strong> value for the <strong>Ph</strong> sensors!\";\n\n// Define the inline keyboard for selecting the minimum threshold for pH sensors\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MIN: 5.5\",\n            \"callback_data\": \"T5 5.5\"\n        }],\n    [\n        {\n            \"text\": \"3.0\",\n            \"callback_data\": \"T5 3.0\"\n        },\n        {\n            \"text\": \"3.5\",\n            \"callback_data\": \"T5 3.5\"\n        },\n        {\n            \"text\": \"4.0\",\n            \"callback_data\": \"T5 4.0\"\n        }\n    ],\n    [\n        {\n            \"text\": \"4.5\",\n            \"callback_data\": \"T5 4.5\"\n        },\n        {\n            \"text\": \"5.0\",\n            \"callback_data\": \"T5 5.0\"\n        },\n        {\n            \"text\": \"5.5\",\n            \"callback_data\": \"T5 5.5\"\n        }\n    ],\n    [\n        {\n            \"text\": \"6.0\",\n            \"callback_data\": \"T5 6.0\"\n        },\n        {\n            \"text\": \"6.5\",\n            \"callback_data\": \"T5 6.5\"\n        },\n        {\n            \"text\": \"7.0\",\n            \"callback_data\": \"T5 7.0\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 2960,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "7b154a32a9946a78",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 5, present step 6",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the updateThresholdsContext\nvar updateThresholdsContext = chatContext.updateThresholdsContext;\n\n// Check if updateThresholdsContext exists\nif (!updateThresholdsContext) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the minimum threshold for pH sensors\nupdateThresholdsContext.ph.min = parseFloat(msg.payload.content.split(\" \")[1]);\n\n// Store the updated threshold configuration in the chat context\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Debugging: Log the stored threshold configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>Minimum Threshold</strong> value for <strong>Ph</strong> sensors is <strong>\" + msg.payload.content.split(\" \")[1] + \"</strong>!\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what will be the <strong>Maximum Threshold</strong> value for the <strong>Ph</strong> sensors!\";\n\n// Define the inline keyboard for selecting the maximum threshold for pH sensors\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MAX: 7.5\",\n            \"callback_data\": \"T6 7.5\"\n        }],\n    [\n        {\n            \"text\": \"7.5\",\n            \"callback_data\": \"T6 7.5\"\n        },\n        {\n            \"text\": \"8.0\",\n            \"callback_data\": \"T6 8.0\"\n        },\n        {\n            \"text\": \"8.5\",\n            \"callback_data\": \"T6 8.5\"\n        }\n    ],\n    [\n        {\n            \"text\": \"9.0\",\n            \"callback_data\": \"T6 9.0\"\n        },\n        {\n            \"text\": \"9.5\",\n            \"callback_data\": \"T6 9.5\"\n        },\n        {\n            \"text\": \"10.0\",\n            \"callback_data\": \"T6 10.0\"\n        }\n    ],\n    [\n        {\n            \"text\": \"10.5\",\n            \"callback_data\": \"T6 10.5\"\n        },\n        {\n            \"text\": \"11.0\",\n            \"callback_data\": \"T6 11.0\"\n        },\n        {\n            \"text\": \"11.5\",\n            \"callback_data\": \"T6 11.5\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 3000,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "c248b16deb8c4683",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 6, present step 7",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Retrieve chat context from the flow\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the updateThresholdsContext\nvar updateThresholdsContext = chatContext.updateThresholdsContext;\n\n// Check if updateThresholdsContext exists\nif (!updateThresholdsContext) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the maximum threshold for pH sensors\nupdateThresholdsContext.ph.max = parseFloat(msg.payload.content.split(\" \")[1]);\n\n// Store the updated threshold configuration in the chat context\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Debugging: Log the stored threshold configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>Maximum Threshold</strong> value for <strong>Ph</strong> sensors is <strong>\" + msg.payload.content.split(\" \")[1] + \"</strong>!\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what will be the <strong>Minimum Threshold</strong> value for the <strong>Salinity</strong> sensors!\";\n\n// Define the inline keyboard for selecting the minimum threshold for Salinity sensors\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MIN: 200 ŒºS/cm\",\n            \"callback_data\": \"T7 200\"\n        }],\n    [\n        {\n            \"text\": \"100 ŒºS/cm\",\n            \"callback_data\": \"T7 100\"\n        },\n        {\n            \"text\": \"200 ŒºS/cm\",\n            \"callback_data\": \"T7 200\"\n        },\n        {\n            \"text\": \"300 ŒºS/cm\",\n            \"callback_data\": \"T7 300\"\n        }\n    ],\n    [\n        {\n            \"text\": \"400 ŒºS/cm\",\n            \"callback_data\": \"T7 400\"\n        },\n        {\n            \"text\": \"500 ŒºS/cm\",\n            \"callback_data\": \"T7 500\"\n        },\n        {\n            \"text\": \"600 ŒºS/cm\",\n            \"callback_data\": \"T7 600\"\n        }\n    ],\n    [\n        {\n            \"text\": \"700 ŒºS/cm\",\n            \"callback_data\": \"T7 700\"\n        },\n        {\n            \"text\": \"800 ŒºS/cm\",\n            \"callback_data\": \"T7 800\"\n        },\n        {\n            \"text\": \"900 ŒºS/cm\",\n            \"callback_data\": \"T7 900\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\n// Configure message options for editing the message\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\n// Prepare the message payload for editing the message text\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 3040,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "76f709bd1353ac86",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 7, present step 8",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the updateThresholdsContext\nvar updateThresholdsContext = chatContext.updateThresholdsContext;\n\n// Check if updateThresholdsContext exists\nif (!updateThresholdsContext) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the minimum threshold for Salinity sensors\nupdateThresholdsContext.salinity.min = parseInt(msg.payload.content.split(\" \")[1], 10);\n\n// Store the updated threshold configuration in the chat context\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Debugging: Log the stored threshold configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>Minimum Threshold</strong> value for <strong>Salinity</strong> sensors is <strong>\" + msg.payload.content.split(\" \")[1] + \" ŒºS/cm</strong>!\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what will be the <strong>Maximum Threshold</strong> value for the <strong>Salinity</strong> sensors!\";\n\n// Define the inline keyboard for selecting the maximum threshold for Salinity sensors\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MAX: 1500 ŒºS/cm\",\n            \"callback_data\": \"T8 1500\"\n        }],\n    [\n        {\n            \"text\": \"1100 ŒºS/cm\",\n            \"callback_data\": \"T8 1100\"\n        },\n        {\n            \"text\": \"1200 ŒºS/cm\",\n            \"callback_data\": \"T8 1200\"\n        },\n        {\n            \"text\": \"1300 ŒºS/cm\",\n            \"callback_data\": \"T8 1300\"\n        }\n    ],\n    [\n        {\n            \"text\": \"1400 ŒºS/cm\",\n            \"callback_data\": \"T8 1400\"\n        },\n        {\n            \"text\": \"1500 ŒºS/cm\",\n            \"callback_data\": \"T8 1500\"\n        },\n        {\n            \"text\": \"1600 ŒºS/cm\",\n            \"callback_data\": \"T8 1600\"\n        }\n    ],\n    [\n        {\n            \"text\": \"1700 ŒºS/cm\",\n            \"callback_data\": \"T8 1700\"\n        },\n        {\n            \"text\": \"1800 ŒºS/cm\",\n            \"callback_data\": \"T8 1800\"\n        },\n        {\n            \"text\": \"1900 ŒºS/cm\",\n            \"callback_data\": \"T8 1900\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 3080,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "2c2dc52b79ba2099",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 8, present step 9",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\nvar updateThresholdsContext = chatContext.updateThresholdsContext;\n\nif (!updateThresholdsContext) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the maximum threshold for Salinity sensors\nupdateThresholdsContext.salinity.max = parseInt(msg.payload.content.split(\" \")[1], 10);\n\n// Store the updated threshold configuration in the chat context\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Debugging: Log the stored threshold configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>Maximum Threshold</strong> value for <strong>Salinity</strong> sensors is <strong>\" + msg.payload.content.split(\" \")[1] + \" ŒºS/cm</strong>!\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what will be the <strong>Minimum Threshold</strong> value for the <strong>Humidity</strong> sensors!\";\n\n// Define the inline keyboard for selecting the minimum threshold for Humidity sensors\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MIN: 30%\",\n            \"callback_data\": \"T9 30\"\n        }],\n    [\n        {\n            \"text\": \"10%\",\n            \"callback_data\": \"T9 10\"\n        },\n        {\n            \"text\": \"20%\",\n            \"callback_data\": \"T9 20\"\n        }\n    ],\n    [\n        {\n            \"text\": \"30%\",\n            \"callback_data\": \"T9 30\"\n        },\n        {\n            \"text\": \"40%\",\n            \"callback_data\": \"T9 40\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 3120,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "34422461f7222e04",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 9, present step 10",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the updateThresholdsContext\nvar updateThresholdsContext = chatContext.updateThresholdsContext;\n\n// Check if updateThresholdsContext exists\nif (!updateThresholdsContext) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the minimum threshold for Humidity sensors\nupdateThresholdsContext.humidity.min = parseInt(msg.payload.content.split(\" \")[1], 10);\n\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Debugging: Log the stored threshold configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>Minimum Threshold</strong> value for <strong>Humidity</strong> sensors is <strong>\" + msg.payload.content.split(\" \")[1] + \"%</strong>!\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what will be the <strong>Maximum Threshold</strong> value for the <strong>Humidity</strong> sensors!\";\n\n// Define the inline keyboard for selecting the maximum threshold for Humidity sensors\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MAX: 90%\",\n            \"callback_data\": \"T10 90\"\n        }],\n    [\n        {\n            \"text\": \"60%\",\n            \"callback_data\": \"T10 60\"\n        },\n        {\n            \"text\": \"70%\",\n            \"callback_data\": \"T10 70\"\n        }\n    ],\n    [\n        {\n            \"text\": \"80%\",\n            \"callback_data\": \"T10 80\"\n        },\n        {\n            \"text\": \"90%\",\n            \"callback_data\": \"T10 90\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 3160,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "140d1cef39a69e71",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 10, present step 11",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the updateThresholdsContext\nvar updateThresholdsContext = chatContext.updateThresholdsContext;\n\n// Retrieve the updateThresholdsContext\nif (!updateThresholdsContext) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the maximum threshold for Humidity sensors\nupdateThresholdsContext.humidity.max = parseInt(msg.payload.content.split(\" \")[1], 10);\n\n// Store the updated threshold configuration in the chat context\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Debugging: Log the stored threshold configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>Maximum Threshold</strong> value for <strong>Humidity</strong> sensors is <strong>\" + msg.payload.content.split(\" \")[1] + \"%</strong>!\\r\\nGreat! \\r\\n\\r\\nNow we have to decide what will be the <strong>Maximum Threshold</strong> value for the <strong>Rain</strong> sensors!\";\n\n// Define the inline keyboard for selecting the maximum threshold for Rain sensors\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [[\n        {\n            \"text\": \"DEFAULT MAX: 40 mm\",\n            \"callback_data\": \"T11 40\"\n        }],\n    [\n        {\n            \"text\": \"5 mm\",\n            \"callback_data\": \"T11 5\"\n        },\n        {\n            \"text\": \"10 mm\",\n            \"callback_data\": \"T11 10\"\n        },\n        {\n            \"text\": \"20 mm\",\n            \"callback_data\": \"T11 20\"\n        }\n    ],\n    [\n        {\n            \"text\": \"30 mm\",\n            \"callback_data\": \"T11 30\"\n        },\n        {\n            \"text\": \"40 mm\",\n            \"callback_data\": \"T11 40\"\n        },\n        {\n            \"text\": \"50 mm\",\n            \"callback_data\": \"T11 50\"\n        }\n    ],\n    [\n        {\n            \"text\": \"‚ùå   ABORT   ‚ùå\",\n            \"callback_data\": \"TCancel\"\n        }]\n    ]\n});\n\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    message_id: chatContext.messageIdChangeThresholds,\n    parse_mode: 'HTML'\n};\n\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\nflow.set(chatContextKey, chatContext);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 3200,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "01373f6a28222ac6",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save step 11, peresent il riepilogo",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"Message ID (messageIdChangeThresholds) not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Retrieve the updateThresholdsContext\nvar updateThresholdsContext = chatContext.updateThresholdsContext;\n\n// Check if updateThresholdsContext exists\nif (!updateThresholdsContext) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Update the maximum threshold for Rain sensors\nupdateThresholdsContext.rain.max = parseInt(msg.payload.content.split(\" \")[1], 10);\n\n// Store the updated threshold configuration in the chat context\nchatContext.updateThresholdsContext = updateThresholdsContext;\n\n// Debugging: Log the stored threshold configuration if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: updateThresholdsContext=\" + JSON.stringify(updateThresholdsContext));\n}\n\n// Prepare the response message\nvar newText = \"OK, the current <strong>Maximum Threshold</strong> value for <strong>Rain</strong> sensors is <strong> \" + msg.payload.content.split(\" \")[1] + \" mm</strong>!\\r\\nExcellent! \\r\\n\\r\\nThis is a summary of the Thresholds:<pre>\" + JSON.stringify(updateThresholdsContext, null, 2) + \"</pre>\\r\\n\\r\\nDo you want to confirm?\";\n\n// Define the inline keyboard for confirming or canceling the changes\nvar reply_markup = JSON.stringify({\n    \"inline_keyboard\": [\n        [\n            {\n                \"text\": \"YES\",\n                \"callback_data\": \"T12 YES\"\n            },\n            {\n                \"text\": \"NO\",\n                \"callback_data\": \"TCancel\"\n            }\n        ]\n    ]\n});\n\nvar options = {\n    chat_id: msg.payload.chatId,\n    reply_markup: reply_markup,\n    parse_mode: 'HTML',\n    message_id: chatContext.messageIdChangeThresholds\n};\n\nmsg.payload.type = 'editMessageText';\nmsg.payload.content = newText;\nmsg.payload.options = options;\n\n\nflow.set(chatContextKey, chatContext);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 3240,
        "wires": [
            [
                "879783e120251e28"
            ]
        ]
    },
    {
        "id": "122668a4219d7510",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Confirm, delete message, send config",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve chat context from the flow\nvar chatContext = flow.get(chatContextKey);\n\n// Check if messageIdChangeThresholds exists in the chat context\nif (!chatContext || !chatContext.messageIdChangeThresholds) {\n    node.error(\"messageIdChangeThresholds ID not found in Flow Context for chatId: \" + chatId);\n    return null;\n}\n\n// Create a copy of the updateThresholdsContext object\nvar updateThresholdsContext = { ...chatContext.updateThresholdsContext }; // Copia dell'oggetto\n\n// Validate that all required properties exist in updateThresholdsContext\nif (!updateThresholdsContext || !updateThresholdsContext.soilMoisture || !updateThresholdsContext.temperature || !updateThresholdsContext.ph || !updateThresholdsContext.salinity || !updateThresholdsContext.humidity || !updateThresholdsContext.rain) {\n    node.error(\"updateThresholdsContext not found in Flow Context for chatId: \" + chatId);\n    node.error(\"!updateThresholdsContext.soilMoisture: \" + !updateThresholdsContext.soilMoisture);\n    node.error(\"!updateThresholdsContext.temperature: \" + !updateThresholdsContext.temperature);\n    node.error(\"!updateThresholdsContext.ph: \" + !updateThresholdsContext.ph);\n    node.error(\"!updateThresholdsContext.salinity: \" + !updateThresholdsContext.salinity);\n    node.error(\"!updateThresholdsContext.humidity: \" + !updateThresholdsContext.humidity);\n    node.error(\"!updateThresholdsContext.rain: \" + !updateThresholdsContext.rain);\n    return null;\n}\n\n// Prepare confirmation message\nvar replyText = \"<strong>Thresholds</strong> Saved and Sent to Server!\";\n\n// Construct the message payload for sending a confirmation message\nvar sendTextMessage = {\n    payload: {\n        chatId: chatId,\n        type: 'message',\n        options: {\n            parse_mode: 'HTML'\n        },\n        content: replyText\n    }\n};\n\n// If there is a message ID to reply to, include it in the message options\nif (chatContext.messageIdToReplayChangeThresholds) {\n    sendTextMessage.payload.options.reply_parameters = {\n        message_id: chatContext.messageIdToReplayChangeThresholds\n    };\n}\n\n// Construct the message payload for deleting the inline keyboard message\nvar deleteInlineMessage = {\n    payload: {\n        chatId: chatId,\n        type: 'deleteMessage',\n        content: chatContext.messageIdChangeThresholds\n    }\n};\n\n// Save the updated thresholds in the global context\nvar updateThresholds = JSON.parse(JSON.stringify(updateThresholdsContext));\nglobal.set(\"sensorsThreshold\", updateThresholds);\n\n// Clean up the chat context by removing threshold change tracking variables\ndelete chatContext.updateThresholdsContext;\ndelete chatContext.messageIdToReplayChangeThresholds;\ndelete chatContext.messageIdChangeThresholds;\nflow.set(chatContextKey, chatContext);\n\n// Return the messages for further processing\nreturn [sendTextMessage, deleteInlineMessage, updateThresholdsContext];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 3300,
        "wires": [
            [
                "879783e120251e28",
                "20b3b83c60c12de1"
            ],
            [
                "879783e120251e28"
            ],
            [
                "1afb0f3b103d6bbb"
            ]
        ]
    },
    {
        "id": "caedbe9a15ad2ed7",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Chek chat, save setting alert",
        "func": "const chatId = msg.payload.chatId;\nconst chatContextKey = \"chat_\" + chatId;\n\n// Retrieve stored chats from global storage or initialize an empty array\nconst storedChats = global.get('chats') || [];\nconst chats = new Map(storedChats);\n//chats.set(chatContextKey, msg.payload.content.split(\" \")[1] == \"YES\");\n\n// Initialize settings object with default value\nconst settings = {};\nsettings.active = true;\n\n// Check if the chat already exists in the stored chats\nif (chats.has(chatContextKey)) {\n    const existingData = chats.get(chatContextKey);\n\n    // Preserve the existing email setting if it exists\n    if (existingData.email) {\n        settings.email = existingData.email;\n    }\n}\n\n// If the chat does not exist in the stored chats, add it with the initialized settings\nif (!chats.has(chatContextKey)) {\n    chats.set(chatContextKey, settings); \n}",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 860,
        "wires": []
    },
    {
        "id": "dfdbee54d49941a8",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/start_simultation",
        "description": "Start sensors simulation",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 300,
        "y": 920,
        "wires": [
            [
                "318fdcc75e0c39d1",
                "152b01ca381cf48a",
                "c4a1f5b76dfd30ec",
                "caedbe9a15ad2ed7"
            ],
            []
        ]
    },
    {
        "id": "318fdcc75e0c39d1",
        "type": "change",
        "z": "bb32693f1e238fb3",
        "name": "set mqtt message",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "avvio",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "sensors/simulation/start",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 550,
        "y": 960,
        "wires": [
            [
                "4df5412302acb979"
            ]
        ]
    },
    {
        "id": "4df5412302acb979",
        "type": "mqtt out",
        "z": "bb32693f1e238fb3",
        "name": "",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "24f8f90e89fb0dcc",
        "x": 870,
        "y": 980,
        "wires": []
    },
    {
        "id": "46b28aa97f46c625",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/stop_simultation",
        "description": "Stop sensors simulation",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 300,
        "y": 1000,
        "wires": [
            [
                "ceada18638c046bf",
                "79942b29501b9633",
                "caedbe9a15ad2ed7"
            ],
            []
        ]
    },
    {
        "id": "ceada18638c046bf",
        "type": "change",
        "z": "bb32693f1e238fb3",
        "name": "set mqtt message",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "stop",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "sensors/simulation/stop",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 550,
        "y": 1040,
        "wires": [
            [
                "4df5412302acb979"
            ]
        ]
    },
    {
        "id": "79942b29501b9633",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Set message",
        "func": "// Initialize the message content with a new line\nvar message = \"\\n\";\nmessage += \"\\nOK, <strong>stop</strong> the sensor simulation!\";\n\n// Set the message payload\nmsg.payload.content = message;\n\n// Define message options to enable HTML formatting\nmsg.payload.options = {\n    parse_mode: 'HTML'\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 1000,
        "wires": [
            [
                "869adba8be69e370"
            ]
        ]
    },
    {
        "id": "869adba8be69e370",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 910,
        "y": 920,
        "wires": [
            []
        ]
    },
    {
        "id": "152b01ca381cf48a",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Set message",
        "func": "// Initialize the message content with a new line\nvar message = \"\\n\";\nmessage += \"\\nGreat! <strong>Start</strong> the sensor simulation!\";\n\n// Set the message payload\nmsg.payload.content = message;\n\n// Define message options to enable HTML formatting\nmsg.payload.options = {\n    parse_mode: 'HTML'\n}\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 920,
        "wires": [
            [
                "869adba8be69e370"
            ]
        ]
    },
    {
        "id": "c4a1f5b76dfd30ec",
        "type": "debug",
        "z": "bb32693f1e238fb3",
        "name": "Telegram message",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1160,
        "y": 920,
        "wires": []
    },
    {
        "id": "149101f4987ee626",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Deactivate alerts",
        "func": "// Retrieve the alert settings from global storage or initialize an empty object\nconst alertSettings = global.get('alertSettings') || {};\n\n// Set the alert status to inactive\nalertSettings.active = false;\n\n// Save the updated alert settings in global storage\nglobal.set('alertSettings', alertSettings);",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 780,
        "wires": []
    },
    {
        "id": "20b3b83c60c12de1",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Activate alerts",
        "func": "// Retrieve the alert settings from global storage or initialize an empty object\nconst alertSettings = global.get('alertSettings') || {};\n\n// Set the alert status to active\nalertSettings.active = true;\n\n// Save the updated alert settings in global storage\nglobal.set('alertSettings', alertSettings);",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 780,
        "wires": []
    },
    {
        "id": "ec4c47a60fc86efe",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/current_thresholds",
        "description": "Get curret the thresholds for alert",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 310,
        "y": 640,
        "wires": [
            [
                "0b5bdeb19e92316e",
                "caedbe9a15ad2ed7"
            ],
            []
        ]
    },
    {
        "id": "0b5bdeb19e92316e",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Get Current thresholds",
        "func": "var chatId = msg.payload.chatId;\nvar chatContextKey = \"chat_\" + chatId;\n\n// Validate chatId: it must exist and be a number\nif (!chatId || typeof chatId !== \"number\") {\n    node.error(\"chatId non valido: \" + chatId);\n    return null;\n}\n\n// Retrieve the sensor thresholds from global storage\nvar thresholds = global.get(\"sensorsThreshold\");\n\n// Prepare the response message containing the current sensor thresholds\nvar replay = {\n    chatId: chatId,\n    content: \"This is the current <strong>Thresholds</strong> of the sensors: <pre>\" + JSON.stringify(thresholds, null, 2) + \"</pre>\",\n    type: \"message\",\n    options: {\n        parse_mode: \"HTML\", // Format message as HTML\n        reply_parameters: {\n            message_id: msg.payload.messageId // Reply to the original message\n        }\n    }\n}\n\n// Wrap the response in the expected format\nvar resp = {}\nresp.payload = replay;\nreturn resp;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 640,
        "wires": [
            [
                "20ac572bbce480fd"
            ]
        ]
    },
    {
        "id": "20ac572bbce480fd",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 870,
        "y": 640,
        "wires": [
            []
        ]
    },
    {
        "id": "7a9b6ee89f80ec87",
        "type": "link out",
        "z": "bb32693f1e238fb3",
        "name": "Send Current Configuration ",
        "mode": "link",
        "links": [
            "c08784a7d0bdacfc"
        ],
        "x": 905,
        "y": 500,
        "wires": []
    },
    {
        "id": "1afb0f3b103d6bbb",
        "type": "link out",
        "z": "bb32693f1e238fb3",
        "name": "Send Current Thresholds",
        "mode": "link",
        "links": [
            "4a8dd89a69cb644a",
            "faab4acb6862989d"
        ],
        "x": 1275,
        "y": 3320,
        "wires": []
    },
    {
        "id": "2e829639469c3d9d",
        "type": "link out",
        "z": "bb32693f1e238fb3",
        "name": "Change Settings",
        "mode": "link",
        "links": [
            "faab4acb6862989d"
        ],
        "x": 1295,
        "y": 2280,
        "wires": []
    },
    {
        "id": "1e59b061de9325aa",
        "type": "link in",
        "z": "bb32693f1e238fb3",
        "name": "Send Alert to Chat",
        "links": [
            "65c9d6a615f74d27"
        ],
        "x": 375,
        "y": 3400,
        "wires": [
            [
                "03af5b055e193375",
                "8180b165454542bb"
            ]
        ]
    },
    {
        "id": "8180b165454542bb",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Get All Chat and Create Messages",
        "func": "function getChatNumbersWithTrue(chats) {\n    // Extract chat numbers where active is true\n    return chats\n        .filter(chat => chat[1].active === true)\n        .map(chat => parseInt(chat[0].split('_')[1]));\n}\nfunction groupAlertsByField(alerts) {\n    // Create an object to group alerts by fieldId\n    const groupedFields = {};\n\n    alerts.forEach(alert => {\n        const { fieldId, sensorType, value, timestamp, threshold } = alert;\n\n        // If the fieldId does not exist yet, initialize it\n        if (!groupedFields[fieldId]) {\n            groupedFields[fieldId] = {\n                fieldId: fieldId,\n                alerts: []\n            };\n        }\n\n        // Add the alert to the corresponding field\n        groupedFields[fieldId].alerts.push({\n            sensorType,\n            value,\n            timestamp,\n            threshold\n        });\n    });\n    return Object.values(groupedFields);\n}\n\nfunction getThresholdEmoji(threshold) {\n    // Determine the appropriate emoji based on the threshold type\n    if (threshold.toLowerCase().includes('min')) {\n        return '‚¨áÔ∏è'; // Minimum threshold\n    } else if (threshold.toLowerCase().includes('max')) {\n        return '‚¨ÜÔ∏è'; // Maximum threshold\n    } else {\n        return '‚ö†Ô∏è'; // Generic threshold\n    }\n}\n\nfunction getUnit(sensorType) {\n    // Return the correct unit for each sensor type\n    switch (sensorType) {\n        case 'ph':\n            return '';\n        case 'salinity':\n            return 'ŒºS/cm';\n        case 'soilMoisture':\n            return '%';\n        case 'temperature':\n            return '¬∞C';\n        case 'humidity':\n            return '%';\n        case 'rain':\n            return 'mm';\n        default:\n            return '';\n    }\n}\n\n// Retrieve alert settings from global context\nconst alertStatus = global.get(\"alertSettings\") || { active: false };\nif (!alertStatus.active) {\n    return null;\n}\n\n// Retrieve active chats\nconst chats = global.get(\"chats\") || [];\nconst chatIds = getChatNumbersWithTrue(chats);\nif (chatIds.length <= 0) {\n    return null;\n}\n\n// Retrieve alerts\nconst alert = msg.alerts || [];\nconst fieldAlert = groupAlertsByField(alert);\nconst m = [];\nfieldAlert.forEach(field => {\n    const formattedFieldId = field.fieldId.replace(/([a-zA-Z])([0-9])/g, '$1 $2');\n    let a = `‚ö†Ô∏è                   <strong>ALERT</strong>                     ‚ö†Ô∏è\\n\\r‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\\n\\rüåªüöú     <strong>‚Äî   ${formattedFieldId.toUpperCase()}  ‚Äî</strong>      üöúüåª\\n\\r‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\\n\\r`;\n    field.alerts.forEach(alert => {\n        const humanReadableTime = new Date(alert.timestamp).toLocaleTimeString('it-IT', {\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit',\n            hourCycle: 'h23'\n        });\n        a = a + `üì°     <strong>‚Äî ${alert.sensorType.toUpperCase()} ‚Äî</strong>     üì°\\n\\r       <strong>Value:</strong>           ${alert.value} ${getUnit(alert.sensorType)}\\n\\r       <strong>Time:</strong>            ${humanReadableTime}\\n\\r       <strong>Threshold:</strong>  ${alert.threshold} ${getUnit(alert.sensorType)} ${getThresholdEmoji(alert.threshold)}\\n\\r‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\\n\\r`;\n    });\n    m.push(a);\n});\n\n// Prepare messages for sending\nlet sendMessages = [];\nm.forEach(a => {\n    const mes = {\n        chatId: chatIds,\n        type: 'message',\n        options: {\n            parse_mode: 'HTML'\n        },\n        content: a\n    };\n    sendMessages.push(mes);\n});\n\n// Prepare the final payload\nmsg = {};\nmsg.payload = sendMessages;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 3400,
        "wires": [
            [
                "b3217bb499a2e98a"
            ]
        ]
    },
    {
        "id": "51629de246e5ec71",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "Alert Sender",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 970,
        "y": 3400,
        "wires": [
            []
        ]
    },
    {
        "id": "03af5b055e193375",
        "type": "debug",
        "z": "bb32693f1e238fb3",
        "name": "RICEVUTO",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 490,
        "y": 3320,
        "wires": []
    },
    {
        "id": "1d4fa3ebecd6de4c",
        "type": "link out",
        "z": "bb32693f1e238fb3",
        "name": "Cambio Condizioni Ambientali",
        "mode": "link",
        "links": [
            "faab4acb6862989d"
        ],
        "x": 1295,
        "y": 2660,
        "wires": []
    },
    {
        "id": "b3217bb499a2e98a",
        "type": "split",
        "z": "bb32693f1e238fb3",
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "property": "payload",
        "x": 810,
        "y": 3400,
        "wires": [
            [
                "51629de246e5ec71"
            ]
        ]
    },
    {
        "id": "66f52b2dca352452",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/generate_report",
        "description": "Generete_report",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 340,
        "y": 3500,
        "wires": [
            [
                "643905519b58426e"
            ],
            []
        ]
    },
    {
        "id": "643905519b58426e",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Set Message for report",
        "func": "// Set the initial message indicating the report generation process\nmsg.payload.content = `Report generation in progress.\n<strong>Please wait...</strong>\nEstimated maximum time 5 min.`;\n\n// Define message options\nconst options = {\n    parse_mode: \"HTML\",\n    reply_parameters: {\n        message_id: msg.messageId\n    }\n};\n\n// Attach the options to the message payload\nmsg.payload.options = options;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 3500,
        "wires": [
            [
                "e0145fc95026ba7e"
            ]
        ]
    },
    {
        "id": "e0145fc95026ba7e",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "Send Message",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 740,
        "y": 3500,
        "wires": [
            [
                "cdbdfa520b94b894"
            ]
        ]
    },
    {
        "id": "cdbdfa520b94b894",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save IdMessaggio messageIdGenerateReport in the ChatContex",
        "func": "var chatId = msg.payload.chatId;\n\n// Validate the chat ID\nif (!chatId || typeof chatId !== \"number\") {\n    node.error(\"chatId non valido: \" + chatId);\n    return null;\n}\n\n// Define the chat context key\nvar chatContextKey = \"chat_\" + chatId;\n\n// Retrieve the existing chat context from the flow, or initialize an empty object\nvar chatContext = flow.get(chatContextKey) || {};\n\n// Store the message IDs related to the report generation process\nchatContext.messageIdToReplayGenerateReport = msg.payload.messageId;\nchatContext.messageIdGenerateReport = msg.payload.sentMessageId;\n\n// Save the updated chat context back to the flow\nflow.set(chatContextKey, chatContext);\n\n// Debugging: Log the stored chat context if internal debugging is enabled\nif (global.get(\"internalDebug\")) {\n    node.warn(\"Saved in Flow: chatContextKey=\" + chatContextKey + \", contenuto=\" + JSON.stringify(chatContext));\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 3500,
        "wires": [
            [
                "149101f4987ee626",
                "fe8844707189a25b"
            ]
        ]
    },
    {
        "id": "8de18e65ae2ede66",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Count message and send file",
        "func": "// Default configuration for the simulation\nconst configDefault = {\n    initialWeather: \"CLOUDY\",\n    fields: [\n        {\n            \"fieldId\": 1,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        },\n        {\n            \"fieldId\": 2,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": false,\n                \"salinity\": false,\n                \"humidity\": true,\n                \"rain\": false\n            }\n        },\n        {\n            \"fieldId\": 3,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        }\n    ],\n    interval: 5000\n};\n\n// Retrieve simulation configuration from global context, or use default\nconst config = global.get(\"simulationConfiguration\") || configDefault;\n\n// Retrieve all keys from the flow context\nvar allKeys = flow.keys();\n\n// Filter only keys that start with \"chat_\"\nvar chatKeys = allKeys.filter(key => key.startsWith(\"chat_\"));\n\n// Prepare an array to store messages to be sent\nvar messages = [];\nvar img = {};\n\n// Iterate through all chat keys and check if they have messageIdGenerateReport\nchatKeys.forEach(chatKey => {\n    var chatContext = flow.get(chatKey);\n    \n    // Check if the \"messageIdGenerateReport\" and \"messageIdToReplayGenerateReport\" properties exist\n    if (chatContext && chatContext.messageIdGenerateReport && chatContext.messageIdToReplayGenerateReport) {\n        // Extract the chat ID from the key\n        var chatId = chatKey.replace(\"chat_\", \"\"); // Estrai l'ID della chat\n        // Prepare the image message to be sent\n        img.payload = {\n            chatId: parseInt(chatId, 10),\n            content: msg.payload,\n            type: \"document\",\n            caption: msg.filename + \".png\",\n            options: {\n                file_name: msg.filename + \".png\",\n                reply_parameters: {\n                    message_id: chatContext.messageIdToReplayGenerateReport\n                }\n            }\n        };\n\n    }\n});\nreturn img;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 3600,
        "wires": [
            [
                "c7040a2b1fa36086",
                "9c0e2335d5d52380"
            ]
        ]
    },
    {
        "id": "688d2049f4fa1856",
        "type": "split",
        "z": "bb32693f1e238fb3",
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "property": "payload",
        "x": 790,
        "y": 3560,
        "wires": [
            [
                "c7040a2b1fa36086"
            ]
        ]
    },
    {
        "id": "c7040a2b1fa36086",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "Send Message",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 980,
        "y": 3600,
        "wires": [
            [
                "160e6d7f91fb017d",
                "7a8d1e3ab341ac3e"
            ]
        ]
    },
    {
        "id": "fe8844707189a25b",
        "type": "link out",
        "z": "bb32693f1e238fb3",
        "name": "Generate Report",
        "mode": "link",
        "links": [
            "7d76f6ba396887ab"
        ],
        "x": 1385,
        "y": 3520,
        "wires": []
    },
    {
        "id": "7cb34e23065ce05a",
        "type": "link in",
        "z": "bb32693f1e238fb3",
        "name": "Send Report Photo",
        "links": [
            "9f6c0b285aa42713"
        ],
        "x": 295,
        "y": 3600,
        "wires": [
            [
                "8de18e65ae2ede66"
            ]
        ]
    },
    {
        "id": "9c0e2335d5d52380",
        "type": "debug",
        "z": "bb32693f1e238fb3",
        "name": "IMG",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 810,
        "y": 3680,
        "wires": []
    },
    {
        "id": "160e6d7f91fb017d",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Track Report Generation & Restore Alerts",
        "func": "// Default configuration for the simulation\nconst configDefault = {\n    initialWeather: \"CLOUDY\",\n    fields: [\n        {\n            \"fieldId\": 1,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        },\n        {\n            \"fieldId\": 2,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": false,\n                \"salinity\": false,\n                \"humidity\": true,\n                \"rain\": false\n            }\n        },\n        {\n            \"fieldId\": 3,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        }\n    ],\n    interval: 5000\n};\n\n// Retrieve simulation configuration from global context or use default\nconst config = global.get(\"simulationConfiguration\") || configDefault;\n\n// Retrieve chat ID\nvar chatId = msg.payload.chatId;\nif (!chatId || typeof chatId !== \"number\") {\n    node.error(\"chatId non valido: \" + chatId);\n    return null;\n}\n\n// Define the chat context key\nvar chatContextKey = \"chat_\" + chatId;\nvar chatContext = flow.get(chatContextKey) || {};\nvar counter = chatContext.counter || 0;\nchatContext.counter = counter + 1;\n\n// Update the chat context in the flow\nflow.set(chatContextKey, chatContext);\n\n// Check if all fields have been processed\nif (chatContext.counter == config.fields.length){\n    msg.payload.type = 'deleteMessage',\n    msg.payload.content = chatContext.messageIdGenerateReport\n    delete chatContext.messageIdToReplayGenerateReport;\n    delete chatContext.messageIdGenerateReport;\n    delete chatContext.counter;\n    flow.set(chatContextKey, chatContext);\n\n    // Reactivate alerts\n    const alertSettings = global.get('alertSettings') || {};\n    alertSettings.active = true;\n    global.set('alertSettings', alertSettings);\n    return msg;\n}\n\n// If not all fields are processed, continue tracking\nflow.set(chatContextKey, chatContext);\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 3600,
        "wires": [
            [
                "c7040a2b1fa36086"
            ]
        ]
    },
    {
        "id": "7a8d1e3ab341ac3e",
        "type": "debug",
        "z": "bb32693f1e238fb3",
        "name": "debug 15",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1180,
        "y": 3560,
        "wires": []
    },
    {
        "id": "3bd8fa4a448cf887",
        "type": "telegram command",
        "z": "bb32693f1e238fb3",
        "name": "",
        "command": "/set_email_notification",
        "description": "Set email Notification",
        "registercommand": true,
        "language": "",
        "scope": "all_private_chats",
        "bot": "227d6c6a69368223",
        "strict": false,
        "hasresponse": true,
        "useregex": false,
        "removeregexcommand": false,
        "outputs": 2,
        "x": 360,
        "y": 3780,
        "wires": [
            [
                "5317834c0d50436b"
            ],
            []
        ]
    },
    {
        "id": "5317834c0d50436b",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Set Message for setting email",
        "func": "// Set the message type as a standard text message\nmsg.payload.type = 'message';\n\n// Define the message content requesting the user's email for alert notifications\nmsg.payload.content = 'Could you kindly provide me with your email so I can use it to send you alerts?';\n\n// Configure message options\nmsg.payload.options = { \n    reply_to_message_id: msg.payload.messageId, \n    reply_markup: { force_reply: true } }\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 3780,
        "wires": [
            [
                "7f738549889592a3"
            ]
        ]
    },
    {
        "id": "7f738549889592a3",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "Send Message",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 840,
        "y": 3780,
        "wires": [
            [
                "6b534249e8a407b2"
            ]
        ]
    },
    {
        "id": "6b534249e8a407b2",
        "type": "telegram reply",
        "z": "bb32693f1e238fb3",
        "name": "",
        "bot": "227d6c6a69368223",
        "x": 1020,
        "y": 3780,
        "wires": [
            [
                "c12b2a25350dd7c4",
                "645f9ea8da41f7c1"
            ]
        ]
    },
    {
        "id": "c12b2a25350dd7c4",
        "type": "function",
        "z": "bb32693f1e238fb3",
        "name": "Save received email",
        "func": "// Function to validate whether a string is a valid email\nfunction isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/; // Regular expression for email validation\n    return emailRegex.test(email);\n}\n\n// Check if the payload contains a valid email\nif (typeof msg.payload.content === 'string' && isValidEmail(msg.payload.content)) {\n    const email = msg.payload.content; // Estrai l'email dal payload\n\n    // Ensure the message contains a valid chat ID\n    if (msg.payload.chatId) {\n        const chatContextKey = `chat_${msg.payload.chatId}`;  // Construct the chat key \"chat_<chatId>\"\n\n        // Retrieve and update the chat map from the global context\n        const storedChats = global.get('chats') || [];\n        const chats = new Map(storedChats);\n\n        // Retrieve existing data or initialize a new object\n        const existingData = chats.get(chatContextKey) || { active: true };\n\n        // Update the data with the new email\n        existingData.email = email;\n        chats.set(chatContextKey, existingData);\n\n        // Save the updated map in the global context\n        global.set('chats', Array.from(chats.entries()));\n\n        // Send a confirmation message\n        msg.payload.content = `Thank you very much!\\n\\rYour <strong>email</strong> (${email}) has been saved and <strong>will be used to send you alerts</strong> if they occur.`;\n    } else {\n        // Error message if the chat ID is missing\n        msg.payload.content = \"<strong>Error</strong>, please try again!\";\n    }\n} else {\n    // Error message if the email format is invalid\n    msg.payload.content = \"<strong>Error.</strong>\\n\\r I did not understand your email, please try again!\";\n}\n\n// Set the message type as a standard text message\nmsg.payload.type = 'message';\nmsg.payload.options = {\n    parse_mode: 'HTML',\n    reply_parameters: {\n        message_id: msg.payload.messageId\n    }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1220,
        "y": 3780,
        "wires": [
            [
                "54d28a0eca3f083e"
            ]
        ]
    },
    {
        "id": "54d28a0eca3f083e",
        "type": "telegram sender",
        "z": "bb32693f1e238fb3",
        "name": "Send Message",
        "bot": "227d6c6a69368223",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1420,
        "y": 3780,
        "wires": [
            []
        ]
    },
    {
        "id": "645f9ea8da41f7c1",
        "type": "debug",
        "z": "bb32693f1e238fb3",
        "name": "debug 17",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1170,
        "y": 3720,
        "wires": []
    },
    {
        "id": "dcd22410200503f2",
        "type": "split",
        "z": "974a61a99863234b",
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "property": "payload",
        "x": 2490,
        "y": 240,
        "wires": [
            [
                "7ef98ba80c4027f0"
            ]
        ]
    },
    {
        "id": "7ef98ba80c4027f0",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Create dashboards",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/dashboards/db",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 2670,
        "y": 240,
        "wires": [
            [
                "3e2dc0f0113f8a5b"
            ]
        ]
    },
    {
        "id": "5eedf4fde1a2ef9d",
        "type": "inject",
        "z": "974a61a99863234b",
        "name": "Create Dashboard and Alerts form Configuration Default",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"initialWeather\":\"CLOUDY\",\"fields\":[{\"fieldId\":1,\"sensors\":{\"soilMoisture\":true,\"temperature\":true,\"ph\":true,\"salinity\":true,\"humidity\":true,\"rain\":true}},{\"fieldId\":2,\"sensors\":{\"soilMoisture\":true,\"temperature\":true,\"ph\":false,\"salinity\":false,\"humidity\":true,\"rain\":false}},{\"fieldId\":3,\"sensors\":{\"soilMoisture\":true,\"temperature\":true,\"ph\":true,\"salinity\":true,\"humidity\":true,\"rain\":true}}],\"interval\":5000}",
        "payloadType": "json",
        "x": 300,
        "y": 240,
        "wires": [
            [
                "8de4b9a40a8cc3dd"
            ]
        ]
    },
    {
        "id": "d75d7b4839b9141f",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Generate Grafana Dashboards",
        "func": "// Converts interval from milliseconds to \"Xs\"\nfunction convertIntervalToRefresh(intervalMs) {\n    const seconds = Math.floor(intervalMs / 1000);\n    return seconds + \"s\"; // Example: 5000 ms -> \"5s\"\n}\n\n// Builds the \"Overview\" panel (row)\nfunction buildOverviewRow() {\n    return {\n        \"type\": \"row\",\n        \"title\": \"Overview\",\n        \"collapsed\": false,\n        \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 0 },\n        \"id\": 999,\n        \"panels\": []\n    };\n}\n\n// Builds the introductory text panel, referring to \"Field X\"\nfunction buildTextPanel(fieldId, sensors) {\n  // Map of sensors with their descriptive names\n  const sensorDescriptions = {\n    soilMoisture: \"Soil Moisture Sensor: Measures soil water content to determine irrigation needs.\",\n    temperature: \"Temperature Sensor: Monitors ambient temperature to assess climate conditions.\",\n    ph: \"Soil pH Sensor: Measures soil acidity/alkalinity to ensure compatibility with crops.\",\n    salinity: \"Water Salinity Sensor: Monitors water salinity levels to ensure optimal irrigation quality.\",\n    humidity: \"Relative Humidity Sensor: Measures air humidity to monitor atmospheric conditions.\",\n    rain: \"Rain Detection Sensor: Detects the presence and intensity of rain to adjust irrigation schedules.\"\n  };\n\n  // Filters sensors with a true value\n  const activeSensors = Object.entries(sensors)\n    .filter(([key, value]) => value)\n    .map(([key]) => `- **${sensorDescriptions[key]}**`)\n    .join(\"\\n\");\n\n  return {\n    \"type\": \"text\",\n    \"title\": \"Dashboard Introduction\",\n    \"id\": 1000,\n    \"gridPos\": {\n      \"h\": 12,\n      \"w\": 24,\n      \"x\": 0,\n      \"y\": 1\n    },\n    \"options\": {\n      \"mode\": \"markdown\",\n      \"content\": `## IoT Sensors Dashboard - Field ${fieldId}\n\nWelcome to the **Field ${fieldId}** monitoring dashboard of the _Smart Agriculture - Field Monitoring System_.\n\n### Overview\nThis dashboard provides real-time monitoring of data from **Field ${fieldId}**, with each row dedicated to a specific sensor.\nUsing data collected from simulated IoT sensors, the system helps identify critical conditions and optimize agricultural resource management.\n\n### Monitored Sensors\n${activeSensors || \"No sensors are currently being monitored.\"}\n\n### Alerts\nUse the **All Alerts** section to check for any anomalies or sensors exceeding desired thresholds.`\n    }\n  };\n}\n\n\n// Builds the \"All Alerts\" row + \"All Active Alerts\" panel\nfunction buildAllAlertsRow(fieldId) {\n    return [\n        {\n            \"type\": \"row\",\n            \"title\": \"All Alerts\",\n            \"collapsed\": false,\n            \"gridPos\": {\n                \"h\": 1,\n                \"w\": 24,\n                \"x\": 0,\n                \"y\": 5\n            },\n            \"id\": 1,\n            \"panels\": []\n        },\n        {\n            \"fieldConfig\": { \"defaults\": {}, \"overrides\": [] },\n            \"gridPos\": {\n                \"h\": 10,\n                \"w\": 24,\n                \"x\": 0,\n                \"y\": 6\n            },\n            \"id\": 2,\n            \"options\": {\n                \"alertInstanceLabelFilter\": \"\",\n                \"alertName\": `Field ${fieldId}`,\n                \"dashboardAlerts\": true,\n                \"folder\": \"\",\n                \"groupBy\": [ \"sensor_type\" ],\n                \"groupMode\": \"custom\",\n                \"maxItems\": 50,\n                \"sortOrder\": 4,\n                \"stateFilter\": {\n                    \"error\": true,\n                    \"firing\": true,\n                    \"noData\": true,\n                    \"normal\": false,\n                    \"pending\": true\n                },\n                \"viewMode\": \"list\"\n            },\n            \"pluginVersion\": \"11.3.1\",\n            \"title\": \"All Active Alerts\",\n            \"type\": \"alertlist\"\n        }\n    ];\n}\n\n// ---------- TEMPERATURE -----------\nfunction buildTemperaturePanels(fieldId, thresholds) {\n    // Row \"Temperature\" + Barchart + Gauge\n    return [\n      {\n        \"collapsed\": false,\n        \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 16 },\n        \"id\": 20,\n        \"panels\": [],\n        \"title\": \"Temperature\",\n        \"type\": \"row\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"custom\": {\n              \"axisBorderShow\": false,\n              \"axisCenteredZero\": true,\n              \"axisColorMode\": \"text\",\n              \"axisLabel\": \"\",\n              \"axisPlacement\": \"auto\",\n              \"fillOpacity\": 80,\n              \"gradientMode\": \"none\",\n              \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n              \"lineWidth\": 1,\n              \"scaleDistribution\": { \"type\": \"linear\" },\n              \"thresholdsStyle\": { \"mode\": \"off\" }\n            },\n            \"mappings\": [],\n            \"max\": 45,\n            \"min\": -15,\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [             \n                { \"color\": \"red\", \"value\": null },\n                { \"color\": \"green\", \"value\": thresholds.min },\n                { \"color\": \"red\", \"value\": thresholds.max }\n              ]\n            },\n            \"unit\": \"celsius\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 11, \"w\": 16, \"x\": 0, \"y\": 17 },\n        \"id\": 21,\n        \"options\": {\n          \"barRadius\": 0,\n          \"barWidth\": 0.97,\n          \"colorByField\": `value {field_id=\"field${fieldId}\", sensor_type=\"temperature\", topic=\"agriculture/field${fieldId}/temperature\"}`,\n          \"fullHighlight\": true,\n          \"groupWidth\": 0.7,\n          \"legend\": {\n            \"calcs\": [],\n            \"displayMode\": \"list\",\n            \"placement\": \"bottom\",\n            \"showLegend\": true\n          },\n          \"orientation\": \"auto\",\n          \"showValue\": \"auto\",\n          \"stacking\": \"normal\",\n          \"tooltip\": { \"mode\": \"single\", \"sort\": \"none\" },\n          \"xTickLabelRotation\": 45,\n          \"xTickLabelSpacing\": -100\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"temperature\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": \"Temperature\",\n        \"type\": \"barchart\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"mappings\": [],\n            \"max\": 45,\n            \"min\": -15,\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"red\", \"value\": null },\n                { \"color\": \"green\", \"value\": thresholds.min },\n                { \"color\": \"red\", \"value\": thresholds.max }\n              ]\n            },\n            \"unit\": \"celsius\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 11, \"w\": 8, \"x\": 16, \"y\": 17 },\n        \"id\": 22,\n        \"options\": {\n          \"minVizHeight\": 75,\n          \"minVizWidth\": 75,\n          \"orientation\": \"auto\",\n          \"reduceOptions\": {\n            \"calcs\": [ \"lastNotNull\" ],\n            \"fields\": `/^value \\\\{field_id=\"field${fieldId}\", sensor_type=\"temperature\", topic=\"agriculture/field${fieldId}/temperature\"\\\\}$/`,\n            \"values\": false\n          },\n          \"showThresholdLabels\": false,\n          \"showThresholdMarkers\": true,\n          \"sizing\": \"auto\"\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"temperature\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": \"Temperature Gauge\",\n        \"type\": \"gauge\"\n      }\n    ];\n}\n\n// ---------- HUMIDITY -----------\nfunction buildHumidityPanels(fieldId, thresholds) {\n    return [\n      {\n        \"collapsed\": false,\n        \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 28 },\n        \"id\": 50,\n        \"panels\": [],\n        \"title\": \"Humidity\",\n        \"type\": \"row\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": {\n              \"mode\": \"thresholds\",\n              \"seriesBy\": \"last\"\n            },\n            \"custom\": {\n              \"axisBorderShow\": false,\n              \"axisCenteredZero\": false,\n              \"axisColorMode\": \"text\",\n              \"axisGridShow\": true,\n              \"axisLabel\": \"\",\n              \"axisPlacement\": \"auto\",\n              \"barAlignment\": 0,\n              \"barWidthFactor\": 0.6,\n              \"drawStyle\": \"line\",\n              \"fillOpacity\": 0,\n              \"gradientMode\": \"none\",\n              \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n              \"insertNulls\": false,\n              \"lineInterpolation\": \"linear\",\n              \"lineWidth\": 1,\n              \"pointSize\": 5,\n              \"scaleDistribution\": { \"type\": \"linear\" },\n              \"showPoints\": \"auto\",\n              \"spanNulls\": false,\n              \"stacking\": { \"group\": \"A\", \"mode\": \"none\" },\n              \"thresholdsStyle\": { \"mode\": \"dashed+area\" }\n            },\n            \"mappings\": [],\n            \"max\": 100,\n            \"min\": 0,\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"red\",    \"value\": null },\n                { \"color\": \"green\", \"value\": thresholds.min   },\n                { \"color\": \"red\", \"value\": thresholds.max   }\n              ]\n            }\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 8, \"w\": 16, \"x\": 0, \"y\": 29 },\n        \"id\": 51,\n        \"options\": {\n          \"legend\": {\n            \"calcs\": [],\n            \"displayMode\": \"list\",\n            \"placement\": \"bottom\",\n            \"showLegend\": false\n          },\n          \"tooltip\": { \"mode\": \"single\", \"sort\": \"none\" }\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"humidity\")\n  |> aggregateWindow(every: 1m, fn: mean, createEmpty: false)\n  |> yield(name: \"mean\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": \"Humidity\",\n        \"type\": \"timeseries\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"mappings\": [],\n            \"max\": 100,\n            \"min\": 0,\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"red\", \"value\": null },\n                { \"color\": \"green\", \"value\": thresholds.min },\n                { \"color\": \"red\", \"value\": thresholds.max }\n              ]\n            },\n            \"unit\": \"percent\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 8, \"w\": 8, \"x\": 16, \"y\": 29 },\n        \"id\": 52,\n        \"options\": {\n          \"colorMode\": \"value\",\n          \"graphMode\": \"area\",\n          \"justifyMode\": \"auto\",\n          \"orientation\": \"auto\",\n          \"percentChangeColorMode\": \"standard\",\n          \"reduceOptions\": {\n            \"calcs\": [ \"lastNotNull\" ],\n            \"fields\": \"\",\n            \"values\": false\n          },\n          \"showPercentChange\": false,\n          \"textMode\": \"auto\",\n          \"wideLayout\": true\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"humidity\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": `Humidity`,\n        \"type\": \"stat\"\n      }\n    ];\n}\n\n// ---------- SOIL MOISTURE -----------\nfunction buildSoilMoisturePanels(fieldId, thresholds) {\n    return [\n      {\n        \"collapsed\": false,\n        \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 37 },\n        \"id\": 10,\n        \"panels\": [],\n        \"title\": \"Soil Moisture\",\n        \"type\": \"row\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"custom\": {\n              \"axisBorderShow\": false,\n              \"axisCenteredZero\": false,\n              \"axisColorMode\": \"text\",\n              \"axisLabel\": \"\",\n              \"axisPlacement\": \"auto\",\n              \"fillOpacity\": 80,\n              \"gradientMode\": \"none\",\n              \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n              \"lineWidth\": 1,\n              \"scaleDistribution\": { \"type\": \"linear\" },\n              \"thresholdsStyle\": { \"mode\": \"off\" }\n            },\n            \"mappings\": [],\n            \"max\": 100,\n            \"min\": 0,\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"red\",    \"value\": null },\n                { \"color\": \"green\", \"value\": thresholds.min   },\n                { \"color\": \"red\", \"value\": thresholds.max   }\n              ]\n            },\n            \"unit\": \"percent\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 8, \"w\": 16, \"x\": 0, \"y\": 38 },\n        \"id\": 11,\n        \"options\": {\n          \"barRadius\": 0,\n          \"barWidth\": 1,\n          \"fullHighlight\": false,\n          \"groupWidth\": 0.7,\n          \"legend\": {\n            \"calcs\": [ \"lastNotNull\" ],\n            \"displayMode\": \"list\",\n            \"placement\": \"right\",\n            \"showLegend\": true\n          },\n          \"orientation\": \"auto\",\n          \"showValue\": \"auto\",\n          \"stacking\": \"none\",\n          \"tooltip\": { \"mode\": \"single\", \"sort\": \"none\" },\n          \"xTickLabelRotation\": 45,\n          \"xTickLabelSpacing\": -100\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"soilMoisture\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": `Soil Moisture`,\n        \"type\": \"barchart\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"mappings\": [],\n            \"max\": 100,\n            \"min\": 0,\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"red\", \"value\": null },\n                { \"color\": \"green\", \"value\": thresholds.min },\n                { \"color\": \"red\", \"value\": thresholds.max }\n              ]\n            },\n            \"unit\": \"percent\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 8, \"w\": 8, \"x\": 16, \"y\": 38 },\n        \"id\": 12,\n        \"options\": {\n          \"colorMode\": \"value\",\n          \"graphMode\": \"area\",\n          \"justifyMode\": \"auto\",\n          \"orientation\": \"auto\",\n          \"percentChangeColorMode\": \"standard\",\n          \"reduceOptions\": {\n            \"calcs\": [ \"lastNotNull\" ],\n            \"fields\": \"\",\n            \"values\": false\n          },\n          \"showPercentChange\": false,\n          \"textMode\": \"auto\",\n          \"wideLayout\": true\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"soilMoisture\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": `Soil Moisture`,\n        \"type\": \"stat\"\n      }\n    ];\n}\n\n// ---------- pH -----------\nfunction buildPhPanels(fieldId, thresholds) {\n    return [\n      {\n        \"collapsed\": false,\n        \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 46 },\n        \"id\": 30,\n        \"panels\": [],\n        \"title\": \"Soil pH\",\n        \"type\": \"row\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"custom\": {\n              \"axisBorderShow\": false,\n              \"axisCenteredZero\": false,\n              \"axisColorMode\": \"text\",\n              \"axisLabel\": \"\",\n              \"axisPlacement\": \"auto\",\n              \"barAlignment\": 0,\n              \"barWidthFactor\": 0.6,\n              \"drawStyle\": \"line\",\n              \"fillOpacity\": 0,\n              \"gradientMode\": \"none\",\n              \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n              \"insertNulls\": false,\n              \"lineInterpolation\": \"linear\",\n              \"lineWidth\": 1,\n              \"pointSize\": 5,\n              \"scaleDistribution\": { \"type\": \"linear\" },\n              \"showPoints\": \"auto\",\n              \"spanNulls\": false,\n              \"stacking\": { \"group\": \"A\", \"mode\": \"none\" },\n              \"thresholdsStyle\": { \"mode\": \"dashed+area\" }\n            },\n            \"fieldMinMax\": true,\n            \"mappings\": [],\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"red\" },\n                { \"color\": \"green\", \"value\": thresholds.min },\n                { \"color\": \"red\", \"value\": thresholds.max  }\n              ]\n            },\n            \"unit\": \"pH\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 8, \"w\": 16, \"x\": 0, \"y\": 47 },\n        \"id\": 32,\n        \"options\": {\n          \"legend\": {\n            \"calcs\": [],\n            \"displayMode\": \"list\",\n            \"placement\": \"bottom\",\n            \"showLegend\": false\n          },\n          \"tooltip\": { \"mode\": \"single\", \"sort\": \"none\" }\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"ph\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": \"Soil pH\",\n        \"type\": \"timeseries\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"mappings\": [],\n            \"max\": 14,\n            \"min\": 0,\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"red\" },\n                { \"color\": \"green\", \"value\": thresholds.min },\n                { \"color\": \"red\", \"value\": thresholds.max }\n              ]\n            },\n            \"unit\": \"none\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 8, \"w\": 8, \"x\": 16, \"y\": 47 },\n        \"id\": 31,\n        \"options\": {\n          \"minVizHeight\": 75,\n          \"minVizWidth\": 75,\n          \"orientation\": \"auto\",\n          \"reduceOptions\": {\n            \"calcs\": [ \"lastNotNull\" ],\n            \"fields\": \"\",\n            \"values\": false\n          },\n          \"showThresholdLabels\": false,\n          \"showThresholdMarkers\": true,\n          \"sizing\": \"auto\"\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"ph\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": `Soil pH`,\n        \"type\": \"gauge\"\n      }\n    ];\n}\n\n// ---------- SALINITY -----------\nfunction buildSalinityPanels(fieldId, thresholds) {\n    return [\n      {\n        \"collapsed\": false,\n        \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 55 },\n        \"id\": 40,\n        \"panels\": [],\n        \"title\": \"Water Salinity\",\n        \"type\": \"row\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"custom\": {\n              \"axisBorderShow\": false,\n              \"axisCenteredZero\": false,\n              \"axisColorMode\": \"text\",\n              \"axisLabel\": \"\",\n              \"axisPlacement\": \"auto\",\n              \"fillOpacity\": 80,\n              \"gradientMode\": \"none\",\n              \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n              \"lineWidth\": 1,\n              \"scaleDistribution\": { \"type\": \"linear\" },\n              \"thresholdsStyle\": { \"mode\": \"off\" }\n            },\n            \"fieldMinMax\": true,\n            \"mappings\": [],\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"red\" },\n                { \"color\": \"green\", \"value\": thresholds.min },\n                { \"color\": \"red\", \"value\": thresholds.max }\n              ]\n            },\n            \"unit\": \"ŒºS/cm\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 8, \"w\": 16, \"x\": 0, \"y\": 56 },\n        \"id\": 42,\n        \"options\": {\n          \"barRadius\": 0,\n          \"barWidth\": 0.97,\n          \"fullHighlight\": false,\n          \"groupWidth\": 0.7,\n          \"legend\": {\n            \"calcs\": [],\n            \"displayMode\": \"list\",\n            \"placement\": \"right\",\n            \"showLegend\": true\n          },\n          \"orientation\": \"auto\",\n          \"showValue\": \"auto\",\n          \"stacking\": \"none\",\n          \"tooltip\": { \"mode\": \"single\", \"sort\": \"none\" },\n          \"xTickLabelRotation\": 45,\n          \"xTickLabelSpacing\": -100\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"salinity\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": `Water Salinity`,\n        \"type\": \"barchart\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"fieldMinMax\": true,\n            \"mappings\": [],\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"red\" },\n                { \"color\": \"green\", \"value\": thresholds.min },\n                { \"color\": \"red\", \"value\": thresholds.max }\n              ]\n            },\n            \"unit\": \"ŒºS/cm\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 8, \"w\": 8, \"x\": 16, \"y\": 56 },\n        \"id\": 41,\n        \"options\": {\n          \"displayMode\": \"gradient\",\n          \"legend\": {\n            \"calcs\": [],\n            \"displayMode\": \"list\",\n            \"placement\": \"bottom\",\n            \"showLegend\": false\n          },\n          \"maxVizHeight\": 300,\n          \"minVizHeight\": 16,\n          \"minVizWidth\": 8,\n          \"namePlacement\": \"auto\",\n          \"orientation\": \"auto\",\n          \"reduceOptions\": {\n            \"calcs\": [ \"lastNotNull\" ],\n            \"fields\": \"\",\n            \"values\": false\n          },\n          \"showUnfilled\": false,\n          \"sizing\": \"auto\",\n          \"valueMode\": \"color\"\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"salinity\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": \"Water Salinity\",\n        \"type\": \"bargauge\"\n      }\n    ];\n}\n\n// ---------- RAIN -----------\nfunction buildRainPanels(fieldId, thresholds) {\n    return [\n      {\n        \"collapsed\": false,\n        \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 64 },\n        \"id\": 60,\n        \"panels\": [],\n        \"title\": \"Rain Detection\",\n        \"type\": \"row\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"custom\": {\n              \"fillOpacity\": 70,\n              \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n              \"insertNulls\": false,\n              \"lineWidth\": 0,\n              \"spanNulls\": false\n            },\n            \"displayName\": \".\",\n            \"fieldMinMax\": false,\n            \"mappings\": [],\n            \"min\": 0,\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"green\" },\n                { \"color\": \"blue\",   \"value\": 1 },\n                { \"color\": \"red\", \"value\": thresholds .max}\n              ]\n            },\n            \"unit\": \"lengthmm\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 8, \"w\": 16, \"x\": 0, \"y\": 65 },\n        \"id\": 62,\n        \"options\": {\n          \"alignValue\": \"left\",\n          \"legend\": {\n            \"displayMode\": \"list\",\n            \"placement\": \"right\",\n            \"showLegend\": true\n          },\n          \"mergeValues\": false,\n          \"rowHeight\": 0.9,\n          \"showValue\": \"auto\",\n          \"tooltip\": { \"mode\": \"multi\", \"sort\": \"none\" }\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"rain\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": \"Rain Detection State\",\n        \"type\": \"state-timeline\"\n      },\n      {\n        \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"color\": { \"mode\": \"thresholds\" },\n            \"mappings\": [],\n            \"thresholds\": {\n              \"mode\": \"absolute\",\n              \"steps\": [\n                { \"color\": \"green\" },\n                { \"color\": \"red\", \"value\": thresholds .max}\n              ]\n            },\n            \"unit\": \"mm\"\n          },\n          \"overrides\": []\n        },\n        \"gridPos\": { \"h\": 8, \"w\": 8, \"x\": 16, \"y\": 65 },\n        \"id\": 61,\n        \"options\": {\n          \"colorMode\": \"value\",\n          \"graphMode\": \"area\",\n          \"justifyMode\": \"auto\",\n          \"orientation\": \"auto\",\n          \"percentChangeColorMode\": \"standard\",\n          \"reduceOptions\": {\n            \"calcs\": [ \"lastNotNull\" ],\n            \"fields\": \"\",\n            \"values\": false\n          },\n          \"showPercentChange\": false,\n          \"textMode\": \"auto\",\n          \"wideLayout\": true\n        },\n        \"pluginVersion\": \"11.3.1\",\n        \"targets\": [\n          {\n            \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"rain\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n            \"refId\": \"A\"\n          }\n        ],\n        \"title\": `Rain Detection`,\n        \"type\": \"stat\"\n      }\n    ];\n}\n\nfunction buildDashboardForField(fieldId, sensors, refreshValue, thresholds) {\n    // Base structure\n    let baseDashboard = {\n      \"dashboard\": {\n        \"annotations\": {\n          \"list\": [\n            {\n              \"builtIn\": 1,\n              \"datasource\": {\n                \"type\": \"grafana\",\n                \"uid\": \"-- Grafana --\"\n              },\n              \"enable\": true,\n              \"hide\": true,\n              \"iconColor\": \"rgba(0, 211, 255, 1)\",\n              \"name\": \"Annotations & Alerts\",\n              \"type\": \"dashboard\"\n            }\n          ]\n        },\n        \"editable\": true,\n        \"fiscalYearStartMonth\": 0,\n        \"graphTooltip\": 0,\n        \"links\": [],\n        \"panels\": [],\n        \"preload\": false,\n        \"refresh\": refreshValue,         // es. \"5s\"\n        \"schemaVersion\": 1,\n        \"tags\": [],\n        \"templating\": { \"list\": [] },\n        \"time\": { \"from\": \"now-15m\", \"to\": \"now\" },\n        \"timepicker\": {},\n        \"timezone\": \"browser\",\n        \"title\": `IoT Sensors Dashboard - Field ${fieldId}`,\n        \"uid\": `iot-sensors-00${fieldId}`,  // uid\n        \"version\": 31,\n        \"weekStart\": \"\"\n      },\n      \"folderUid\": \"SA-FMS\",\n      \"isFolder\": false,\n      \"overwrite\": true\n    };\n\n    // (1) Row \"Overview\"\n    baseDashboard.dashboard.panels.push(buildOverviewRow());\n    // (2) Text panel\n    baseDashboard.dashboard.panels.push(buildTextPanel(fieldId, sensors));\n    // (3) All Alerts row\n    const alertsPanels = buildAllAlertsRow(fieldId);\n    baseDashboard.dashboard.panels.push(...alertsPanels);\n\n    if (sensors.temperature) {\n        baseDashboard.dashboard.panels.push(...buildTemperaturePanels(fieldId, thresholds.temperature));\n    }\n    if (sensors.humidity) {\n      baseDashboard.dashboard.panels.push(...buildHumidityPanels(fieldId, thresholds.humidity));\n    }\n    if (sensors.soilMoisture) {\n      baseDashboard.dashboard.panels.push(...buildSoilMoisturePanels(fieldId, thresholds.soilMoisture));\n    }\n    if (sensors.ph) {\n      baseDashboard.dashboard.panels.push(...buildPhPanels(fieldId, thresholds.ph));\n    }\n    if (sensors.salinity) {\n      baseDashboard.dashboard.panels.push(...buildSalinityPanels(fieldId, thresholds.salinity));\n    }\n    if (sensors.rain) {\n      baseDashboard.dashboard.panels.push(...buildRainPanels(fieldId, thresholds.rain));\n    }\n\n    return baseDashboard;\n}\n\nlet conf = {\n    \"initialWeather\": \"CLOUDY\",\n    \"fields\": [\n        {\n            \"fieldId\": 1,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        },\n        {\n            \"fieldId\": 2,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": false,\n                \"salinity\": false,\n                \"humidity\": true,\n                \"rain\": false\n            }\n        },\n        {\n            \"fieldId\": 3,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        }\n    ],\n    \"interval\": 5000\n};\n\nlet input = global.get(\"simulationConfiguration\") || conf;\n\nlet thresholds = {\n    \"soilMoisture\": {\n        \"min\": 20,\n        \"max\": 80\n    },\n    \"temperature\": {\n        \"min\": 0,\n        \"max\": 35\n    },\n    \"ph\": {\n        \"min\": 5.5,\n        \"max\": 7.5\n    },\n    \"salinity\": {\n        \"min\": 200,\n        \"max\": 1500\n    },\n    \"humidity\": {\n        \"min\": 50,\n        \"max\": 90\n    },\n    \"rain\": {\n        \"max\": 40\n    }\n};\n\nconst thresholdConfig = global.get(\"sensorsThreshold\") || thresholds;\n\n// Convert interval (ms) in \"Xs\"\nlet refreshStr = convertIntervalToRefresh(input.interval);\n\n// Create an array of dashboards\nlet dashboards = [];\n\nfor (let f of input.fields) {\n    let fieldId = f.fieldId;\n    let sensors = f.sensors;\n    \n    let dash = buildDashboardForField(fieldId, sensors, refreshStr, thresholdConfig);\n    dashboards.push(dash);\n}\n\nmsg.payload = dashboards;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2270,
        "y": 240,
        "wires": [
            [
                "dcd22410200503f2"
            ]
        ]
    },
    {
        "id": "4e5b902ccda129bf",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Delete folder - dashboard - alert rules",
        "method": "DELETE",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/folders/SA-FMS?forceDeleteRules=true",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 1170,
        "y": 240,
        "wires": [
            [
                "b80b58d3eab270de"
            ]
        ]
    },
    {
        "id": "2f7225cc61592538",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Create the folder",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/folders",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 2010,
        "y": 240,
        "wires": [
            [
                "d75d7b4839b9141f"
            ]
        ]
    },
    {
        "id": "39c9855ab18c75ca",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Set configuration in context",
        "func": "// Retrieve the simulation configuration from the global context\n// If it doesn't exist, keep the current msg.payload\nmsg.payload = global.get(\"simulationConfiguration\") || msg.payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 240,
        "wires": [
            [
                "4e5b902ccda129bf"
            ]
        ]
    },
    {
        "id": "9db46381144a9ef5",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Create the folder",
        "func": "msg = {}\n\n// Define a folder object containing details about the Smart Agriculture system\nlet folder = {\n    \"description\": \"Smart Agriculture - Field Monitoring System title\",\n    \"title\": \"Smart Agriculture - Field Monitoring System\",\n    \"uid\": \"SA-FMS\"\n}\n\n// Assign the folder object to the message payload\nmsg.payload = folder;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1790,
        "y": 240,
        "wires": [
            [
                "2f7225cc61592538"
            ]
        ]
    },
    {
        "id": "dd51c9cbc1a93eb3",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "4e5b902ccda129bf"
        ],
        "uncaught": false,
        "x": 1090,
        "y": 160,
        "wires": [
            [
                "6992a10864d7ace0"
            ]
        ]
    },
    {
        "id": "6992a10864d7ace0",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1260,
        "y": 160,
        "wires": [
            [
                "4e5b902ccda129bf"
            ]
        ]
    },
    {
        "id": "9228b0b8979e0e2a",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "2f7225cc61592538"
        ],
        "uncaught": false,
        "x": 1830,
        "y": 300,
        "wires": [
            [
                "01c0266334955a32"
            ]
        ]
    },
    {
        "id": "01c0266334955a32",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 2000,
        "y": 300,
        "wires": [
            [
                "2f7225cc61592538"
            ]
        ]
    },
    {
        "id": "26587e674b577a79",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "7ef98ba80c4027f0"
        ],
        "uncaught": false,
        "x": 2330,
        "y": 300,
        "wires": [
            [
                "70a9d76a68c274ab"
            ]
        ]
    },
    {
        "id": "70a9d76a68c274ab",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 2480,
        "y": 300,
        "wires": [
            [
                "7ef98ba80c4027f0"
            ]
        ]
    },
    {
        "id": "eb4ac7b5353e9dc9",
        "type": "split",
        "z": "974a61a99863234b",
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "property": "payload",
        "x": 3870,
        "y": 240,
        "wires": [
            [
                "b1364737e97e97b0"
            ]
        ]
    },
    {
        "id": "b1364737e97e97b0",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Create Alert Rules",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/v1/provisioning/alert-rules",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 4050,
        "y": 240,
        "wires": [
            [
                "6e373b78b8eb5ec0"
            ]
        ]
    },
    {
        "id": "772d21da4d18faaa",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Generate Grafana Alerts",
        "func": "/**\n * This Function node dynamically creates alerts based on\n * the global configuration.fields and example templates\n * provided. It returns an array of JSON in msg.payload.\n */\n\nlet conf = {\n    \"initialWeather\": \"CLOUDY\",\n    \"fields\": [\n        {\n            \"fieldId\": 1,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        },\n        {\n            \"fieldId\": 2,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": false,\n                \"salinity\": false,\n                \"humidity\": true,\n                \"rain\": false\n            }\n        },\n        {\n            \"fieldId\": 3,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        }\n    ],\n    \"interval\": 5000\n};\n\nconst config = global.get(\"simulationConfiguration\") || conf;\n\nconst templates = {\n\n    humidity: `{\n        \"uid\":\"humidity-field1\",\n        \"orgID\": 1,\n        \"folderUID\": \"SA-FMS\",\n        \"ruleGroup\": \"10 seconds\",\n        \"title\": \"Humidity Field 1\",\n        \"condition\": \"C\",\n        \"data\": [\n            {\n                \"refId\": \"A\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 900,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"fe9sepcaz6iv4a\",\n                \"model\": {\n                    \"datasource\": {\n                        \"type\": \"influxdb\",\n                        \"uid\": \"fe9sepcaz6iv4a\"\n                    },\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"query\": \"from(bucket: \\\\\"SA-FMS\\\\\")\\\\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\\\\n  |> filter(fn: (r) => r[\\\\\"_measurement\\\\\"] == \\\\\"smart_agriculture_measurements\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"field_id\\\\\"] == \\\\\"field1\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"sensor_type\\\\\"] == \\\\\"humidity\\\\\")\\\\n  |> aggregateWindow(every: 1m, fn: mean, createEmpty: false)\\\\n  |> yield(name: \\\\\"mean\\\\\")\",\n                    \"refId\": \"A\"\n                }\n            },\n            {\n                \"refId\": \"B\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [],\n                                \"type\": \"gt\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"B\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\"\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"A\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"reducer\": \"last\",\n                    \"refId\": \"B\",\n                    \"type\": \"reduce\"\n                }\n            },\n            {\n                \"refId\": \"C\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [\n                                    50,\n                                    90\n                                ],\n                                \"type\": \"outside_range\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"C\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\",\n                            \"unloadEvaluator\": {\n                                \"params\": [\n                                    50,\n                                    90\n                                ],\n                                \"type\": \"within_range\"\n                            }\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"B\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"refId\": \"C\",\n                    \"type\": \"threshold\"\n                }\n            }\n        ],\n        \"updated\": \"2025-01-20T11:00:09Z\",\n        \"noDataState\": \"NoData\",\n        \"execErrState\": \"Error\",\n        \"for\": \"0s\",\n        \"annotations\": {\n            \"__dashboardUid__\": \"iot-sensors-001\",\n            \"__panelId__\": \"18\"\n        },\n        \"labels\": {\n            \"Field\": \"1\"\n        },\n        \"isPaused\": false,\n        \"notification_settings\": {\n            \"receiver\": \"default-email\",\n            \"group_interval\": \"10s\",\n            \"group_wait\": \"0s\"\n        },\n        \"record\": null\n    }`,\n\n    temperature: `{\n        \"uid\":\"temperature-field1\",\n        \"orgID\": 1,\n        \"folderUID\": \"SA-FMS\",\n        \"ruleGroup\": \"10 seconds\",\n        \"title\": \"Temperature Field 1\",\n        \"condition\": \"C\",\n        \"data\": [\n            {\n                \"refId\": \"A\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 900,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"fe9sepcaz6iv4a\",\n                \"model\": {\n                    \"datasource\": {\n                        \"type\": \"influxdb\",\n                        \"uid\": \"fe9sepcaz6iv4a\"\n                    },\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"query\": \"from(bucket: \\\\\"SA-FMS\\\\\")\\\\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\\\\n  |> filter(fn: (r) => r[\\\\\"_measurement\\\\\"] == \\\\\"smart_agriculture_measurements\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"field_id\\\\\"] == \\\\\"field1\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"sensor_type\\\\\"] == \\\\\"temperature\\\\\")\\\\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\\\\n  |> yield(name: \\\\\"last\\\\\")\",\n                    \"refId\": \"A\"\n                }\n            },\n            {\n                \"refId\": \"B\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [],\n                                \"type\": \"gt\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"B\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\"\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"A\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"reducer\": \"last\",\n                    \"refId\": \"B\",\n                    \"type\": \"reduce\"\n                }\n            },\n            {\n                \"refId\": \"C\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [\n                                    0,\n                                    35\n                                ],\n                                \"type\": \"outside_range\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"C\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\",\n                            \"unloadEvaluator\": {\n                                \"params\": [\n                                    0,\n                                    35\n                                ],\n                                \"type\": \"within_range\"\n                            }\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"B\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"refId\": \"C\",\n                    \"type\": \"threshold\"\n                }\n            }\n        ],\n        \"updated\": \"2025-01-20T11:00:09Z\",\n        \"noDataState\": \"NoData\",\n        \"execErrState\": \"Error\",\n        \"for\": \"0s\",\n        \"annotations\": {\n            \"__dashboardUid__\": \"iot-sensors-001\",\n            \"__panelId__\": \"15\"\n        },\n        \"labels\": {\n            \"Field\": \"1\"\n        },\n        \"isPaused\": false,\n        \"notification_settings\": {\n            \"receiver\": \"default-email\",\n            \"group_interval\": \"10s\",\n            \"group_wait\": \"0s\"\n        },\n        \"record\": null\n    }`,\n\n    soilMoisture: `{\n        \"uid\":\"soilMoisture-field1\",\n        \"orgID\": 1,\n        \"folderUID\": \"SA-FMS\",\n        \"ruleGroup\": \"10 seconds\",\n        \"title\": \"Soil Moisture Field 1\",\n        \"condition\": \"C\",\n        \"data\": [\n            {\n                \"refId\": \"A\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 900,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"fe9sepcaz6iv4a\",\n                \"model\": {\n                    \"datasource\": {\n                        \"type\": \"influxdb\",\n                        \"uid\": \"fe9sepcaz6iv4a\"\n                    },\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"query\": \"from(bucket: \\\\\"SA-FMS\\\\\")\\\\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\\\\n  |> filter(fn: (r) => r[\\\\\"_measurement\\\\\"] == \\\\\"smart_agriculture_measurements\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"field_id\\\\\"] == \\\\\"field1\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"sensor_type\\\\\"] == \\\\\"soilMoisture\\\\\")\\\\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\\\\n  |> yield(name: \\\\\"last\\\\\")\",\n                    \"refId\": \"A\"\n                }\n            },\n            {\n                \"refId\": \"B\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [],\n                                \"type\": \"gt\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"B\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\"\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"A\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"reducer\": \"last\",\n                    \"refId\": \"B\",\n                    \"type\": \"reduce\"\n                }\n            },\n            {\n                \"refId\": \"C\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [\n                                    20,\n                                    80\n                                ],\n                                \"type\": \"outside_range\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"C\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\",\n                            \"unloadEvaluator\": {\n                                \"params\": [\n                                    20,\n                                    80\n                                ],\n                                \"type\": \"within_range\"\n                            }\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"B\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"refId\": \"C\",\n                    \"type\": \"threshold\"\n                }\n            }\n        ],\n        \"updated\": \"2025-01-20T11:00:09Z\",\n        \"noDataState\": \"NoData\",\n        \"execErrState\": \"Error\",\n        \"for\": \"0s\",\n        \"annotations\": {\n            \"__dashboardUid__\": \"iot-sensors-001\",\n            \"__panelId__\": \"111\"\n        },\n        \"labels\": {\n            \"Field\": \"1\"\n        },\n        \"isPaused\": false,\n        \"notification_settings\": {\n            \"receiver\": \"default-email\",\n            \"group_interval\": \"10s\",\n            \"group_wait\": \"0s\"\n        },\n        \"record\": null\n    }`,\n\n    ph: `{\n        \"uid\":\"ph-field1\",\n        \"orgID\": 1,\n        \"folderUID\": \"SA-FMS\",\n        \"ruleGroup\": \"10 seconds\",\n        \"title\": \"Soil pH Field 1\",\n        \"condition\": \"C\",\n        \"data\": [\n            {\n                \"refId\": \"A\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 900,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"fe9sepcaz6iv4a\",\n                \"model\": {\n                    \"datasource\": {\n                        \"type\": \"influxdb\",\n                        \"uid\": \"fe9sepcaz6iv4a\"\n                    },\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"query\": \"from(bucket: \\\\\"SA-FMS\\\\\")\\\\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\\\\n  |> filter(fn: (r) => r[\\\\\"_measurement\\\\\"] == \\\\\"smart_agriculture_measurements\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"field_id\\\\\"] == \\\\\"field1\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"sensor_type\\\\\"] == \\\\\"ph\\\\\")\\\\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\\\\n  |> yield(name: \\\\\"last\\\\\")\",\n                    \"refId\": \"A\"\n                }\n            },\n            {\n                \"refId\": \"B\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [],\n                                \"type\": \"gt\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"B\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\"\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"A\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"reducer\": \"last\",\n                    \"refId\": \"B\",\n                    \"type\": \"reduce\"\n                }\n            },\n            {\n                \"refId\": \"C\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [\n                                    5.5,\n                                    7.5\n                                ],\n                                \"type\": \"outside_range\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"C\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\",\n                            \"unloadEvaluator\": {\n                                \"params\": [\n                                    5.5,\n                                    7.5\n                                ],\n                                \"type\": \"within_range\"\n                            }\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"B\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"refId\": \"C\",\n                    \"type\": \"threshold\"\n                }\n            }\n        ],\n        \"updated\": \"2025-01-20T11:00:09Z\",\n        \"noDataState\": \"NoData\",\n        \"execErrState\": \"Error\",\n        \"for\": \"0s\",\n        \"annotations\": {\n            \"__dashboardUid__\": \"iot-sensors-001\",\n            \"__panelId__\": \"114\"\n        },\n        \"labels\": {\n            \"Field\": \"1\"\n        },\n        \"isPaused\": false,\n        \"notification_settings\": {\n            \"receiver\": \"default-email\",\n            \"group_interval\": \"10s\",\n            \"group_wait\": \"0s\"\n        },\n        \"record\": null\n    }`,\n\n    salinity: `{\n        \"uid\":\"salinity-field1\",\n        \"orgID\": 1,\n        \"folderUID\": \"SA-FMS\",\n        \"ruleGroup\": \"10 seconds\",\n        \"title\": \"Water Salinity Field 1\",\n        \"condition\": \"C\",\n        \"data\": [\n            {\n                \"refId\": \"A\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 900,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"fe9sepcaz6iv4a\",\n                \"model\": {\n                    \"datasource\": {\n                        \"type\": \"influxdb\",\n                        \"uid\": \"fe9sepcaz6iv4a\"\n                    },\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"query\": \"from(bucket: \\\\\"SA-FMS\\\\\")\\\\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\\\\n  |> filter(fn: (r) => r[\\\\\"_measurement\\\\\"] == \\\\\"smart_agriculture_measurements\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"field_id\\\\\"] == \\\\\"field1\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"sensor_type\\\\\"] == \\\\\"salinity\\\\\")\\\\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\\\\n  |> yield(name: \\\\\"last\\\\\")\",\n                    \"refId\": \"A\"\n                }\n            },\n            {\n                \"refId\": \"B\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [],\n                                \"type\": \"gt\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"B\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\"\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"A\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"reducer\": \"last\",\n                    \"refId\": \"B\",\n                    \"type\": \"reduce\"\n                }\n            },\n            {\n                \"refId\": \"C\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [\n                                    200,\n                                    1500\n                                ],\n                                \"type\": \"outside_range\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"C\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\"\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"B\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"refId\": \"C\",\n                    \"type\": \"threshold\"\n                }\n            }\n        ],\n        \"updated\": \"2025-01-20T11:00:09Z\",\n        \"noDataState\": \"NoData\",\n        \"execErrState\": \"Error\",\n        \"for\": \"0s\",\n        \"annotations\": {\n            \"__dashboardUid__\": \"iot-sensors-001\",\n            \"__panelId__\": \"117\"\n        },\n        \"labels\": {\n            \"Field\": \"1\"\n        },\n        \"isPaused\": false,\n        \"notification_settings\": {\n            \"receiver\": \"default-email\",\n            \"group_interval\": \"10s\",\n            \"group_wait\": \"0s\"\n        },\n        \"record\": null\n    }`,\n\n    rain: `{\n        \"uid\":\"rain-field1\",\n        \"orgID\": 1,\n        \"folderUID\": \"SA-FMS\",\n        \"ruleGroup\": \"10 seconds\",\n        \"title\": \"Rain Detection State Field 1\",\n        \"condition\": \"C\",\n        \"data\": [\n            {\n                \"refId\": \"A\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 900,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"fe9sepcaz6iv4a\",\n                \"model\": {\n                    \"datasource\": {\n                        \"type\": \"influxdb\",\n                        \"uid\": \"fe9sepcaz6iv4a\"\n                    },\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"query\": \"from(bucket: \\\\\"SA-FMS\\\\\")\\\\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\\\\n  |> filter(fn: (r) => r[\\\\\"_measurement\\\\\"] == \\\\\"smart_agriculture_measurements\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"field_id\\\\\"] == \\\\\"field1\\\\\")\\\\n  |> filter(fn: (r) => r[\\\\\"sensor_type\\\\\"] == \\\\\"rain\\\\\")\\\\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\\\\n  |> yield(name: \\\\\"last\\\\\")\",\n                    \"refId\": \"A\"\n                }\n            },\n            {\n                \"refId\": \"B\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [],\n                                \"type\": \"gt\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"B\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\"\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"A\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"reducer\": \"last\",\n                    \"refId\": \"B\",\n                    \"type\": \"reduce\"\n                }\n            },\n            {\n                \"refId\": \"C\",\n                \"queryType\": \"\",\n                \"relativeTimeRange\": {\n                    \"from\": 0,\n                    \"to\": 0\n                },\n                \"datasourceUid\": \"__expr__\",\n                \"model\": {\n                    \"conditions\": [\n                        {\n                            \"evaluator\": {\n                                \"params\": [\n                                    40\n                                ],\n                                \"type\": \"gt\"\n                            },\n                            \"operator\": {\n                                \"type\": \"and\"\n                            },\n                            \"query\": {\n                                \"params\": [\n                                    \"C\"\n                                ]\n                            },\n                            \"reducer\": {\n                                \"params\": [],\n                                \"type\": \"last\"\n                            },\n                            \"type\": \"query\",\n                            \"unloadEvaluator\": {\n                                \"params\": [\n                                    40\n                                ],\n                                \"type\": \"lt\"\n                            }\n                        }\n                    ],\n                    \"datasource\": {\n                        \"type\": \"__expr__\",\n                        \"uid\": \"__expr__\"\n                    },\n                    \"expression\": \"B\",\n                    \"intervalMs\": 1000,\n                    \"maxDataPoints\": 43200,\n                    \"refId\": \"C\",\n                    \"type\": \"threshold\"\n                }\n            }\n        ],\n        \"updated\": \"2025-01-20T11:00:09Z\",\n        \"noDataState\": \"NoData\",\n        \"execErrState\": \"Error\",\n        \"for\": \"0s\",\n        \"annotations\": {\n            \"__dashboardUid__\": \"iot-sensors-001\",\n            \"__panelId__\": \"120\"\n        },\n        \"labels\": {\n            \"Field\": \"1\"\n        },\n        \"isPaused\": false,\n        \"notification_settings\": {\n            \"receiver\": \"default-email\",\n            \"group_interval\": \"10s\",\n            \"group_wait\": \"0s\"\n        },\n        \"record\": null\n    }`\n};\n\nfunction replaceFieldReferences(templateStr, fieldId) {\n    let out = templateStr;\n\n    out = out.replaceAll(\"field1\", \"field\" + fieldId);\n\n    out = out.replaceAll(\"Field 1\", \"Field \" + fieldId);\n\n    out = out.replaceAll(\"\\\"Field\\\": \\\"1\\\"\", `\"Field\": \"${fieldId}\"`);\n\n    out = out.replaceAll(\"iot-sensors-001\", \"iot-sensors-00\" + fieldId);\n\n    return out;\n}\n\nlet alerts = [];\n\nif (config && config.fields && Array.isArray(config.fields)) {\n    for (let f of config.fields) {\n        let fid = f.fieldId;         \n        let sensors = f.sensors;     \n\n        for (let sensorKey in sensors) {\n            if (sensors[sensorKey] === true) {\n                let sensorTemplate = templates[sensorKey];\n                if (sensorTemplate) {\n                    let replaced = replaceFieldReferences(sensorTemplate, fid);\n\n                    let alertObj = JSON.parse(replaced);\n\n                    alerts.push(alertObj);\n                }\n            }\n        }\n    }\n}\n\nlet thresholds = {\n    \"soilMoisture\": {\n        \"min\": 20,\n        \"max\": 80\n    },\n    \"temperature\": {\n        \"min\": 0,\n        \"max\": 35\n    },\n    \"ph\": {\n        \"min\": 5.5,\n        \"max\": 7.5\n    },\n    \"salinity\": {\n        \"min\": 200,\n        \"max\": 1500\n    },\n    \"humidity\": {\n        \"min\": 50,\n        \"max\": 90\n    },\n    \"rain\": {\n        \"max\": 40\n    }\n};\n\n\nconst thresholdConfig = global.get(\"sensorsThreshold\") || thresholds;\n\nfor (let i = 0; i < alerts.length; i++) {\n    let alert = alerts[i];\n\n    const uid = alert?.uid;\n    if (!uid) {\n\n        continue;\n    }\n\n\n    const parts = uid.split(\"-\");\n    if (parts.length < 2) {\n\n        continue;\n    }\n    const sensorType = parts[0];\n\n    const sensorThreshold = thresholdConfig[sensorType];\n    if (!sensorThreshold) {\n        continue;\n    }\n\n    let cData = alert.data.find(d => d.refId === \"C\");\n    if (!cData || !cData.model || !cData.model.conditions || !cData.model.conditions[0]) {\n\n        continue;\n    }\n\n    let condition = cData.model.conditions[0];\n    let evaluator = condition.evaluator;\n    let unloadEval = condition.unloadEvaluator;\n\n\n    if (sensorThreshold.min !== undefined && sensorThreshold.max !== undefined) {\n\n        evaluator.params = [sensorThreshold.min, sensorThreshold.max];\n        if (unloadEval) {\n            unloadEval.params = [sensorThreshold.min, sensorThreshold.max];\n        }\n    } else if (sensorThreshold.max !== undefined) {\n\n        evaluator.params = [sensorThreshold.max];\n        if (unloadEval) {\n            unloadEval.params = [sensorThreshold.max];\n        }\n    }\n\n}\n\nmsg.payload = alerts;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3670,
        "y": 240,
        "wires": [
            [
                "eb4ac7b5353e9dc9"
            ]
        ]
    },
    {
        "id": "2892453dd410c056",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "b1364737e97e97b0"
        ],
        "uncaught": false,
        "x": 3710,
        "y": 200,
        "wires": [
            [
                "688b64abe9fd6605"
            ]
        ]
    },
    {
        "id": "688b64abe9fd6605",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 3860,
        "y": 200,
        "wires": [
            [
                "b1364737e97e97b0"
            ]
        ]
    },
    {
        "id": "3e2dc0f0113f8a5b",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Count create request and generate email contact point",
        "func": "let defaultEmails = \"default@example.com\";\n// Retrieve chats from the global context\nconst storedChats = global.get('chats') || [];\nconst chats = new Map(storedChats);\n\n// Array to store emails\nconst emails = [];\n\n// Iterate through all keys in the chat map\nfor (const [key, value] of chats.entries()) {\n    // Check if the object has an email and is active\n    if (value.active && value.email) {\n        emails.push(value.email); // Add the email to the array\n    }\n}\n\nif(emails.length > 1){\n    defaultEmails = emails.join(';');\n} else if (emails.length == 1) {\n    defaultEmails = emails[0];\n}\n\nmsg.payload = {\n    \"uid\": \"default-contact-point\",\n    \"name\": \"default-email\",\n    \"type\": \"email\",\n    \"settings\": {\n        \"addresses\": defaultEmails,\n        \"message\": `{{ define \"custom.message\" }}\n# üìä Smart Agriculture - Field Monitoring System\n \n{{ if gt (len .Alerts.Firing) 0 }}\n## ‚ö†Ô∏è Firing Alerts\n{{ range .Alerts.Firing }}\n- **Alert**: {{ .Labels.alertname }}\n  - **Field**: {{ .Labels.Field }}\n  - **Value**: {{ .ValueString }}\n  - **Description**: {{ .Annotations.description }}\n  - [View in Grafana]({{ .GeneratorURL }})\n{{ end }}\n{{ end }}\n \n{{ if gt (len .Alerts.Resolved) 0 }}\n## ‚úÖ Resolved Alerts\n{{ range .Alerts.Resolved }}\n- **Alert**: {{ .Labels.alertname }}\n  - **Field**: {{ .Labels.Field }}\n  - **Value**: {{ .ValueString }}\n  - **Description**: {{ .Annotations.description }}\n  - [View in Grafana]({{ .GeneratorURL }})\n{{ end }}\n{{ end }}\n \n---\n*This notification was generated by Grafana.*\n{{ end }}\n{{custom.message}}\n`,\n        \"singleEmail\": false,\n        \"subject\": `{{ define \"custom.subject\" }}\n[{{ .Status | title }}] üìä Smart Agriculture -\n{{ if gt (len .Alerts.Firing) 0 }} {{ len .Alerts.Firing }} Firing {{ end }}\n{{ if gt (len .Alerts.Resolved) 0 }} {{ len .Alerts.Resolved }} Resolved {{ end }}\n - {{ .CommonLabels.alertname }}\n{{ end }}`\n    },\n    \"disableResolveMessage\": false\n};\n\nlet defaultConfiguration = {\n    \"initialWeather\": \"CLOUDY\",\n    \"fields\": [\n        {\n            \"fieldId\": 1,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        },\n        {\n            \"fieldId\": 2,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": false,\n                \"salinity\": false,\n                \"humidity\": true,\n                \"rain\": false\n            }\n        },\n        {\n            \"fieldId\": 3,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        }\n    ],\n    \"interval\": 5000\n};\n\n// Retrieve the global configuration\nlet configuration = global.get(\"simulationConfiguration\") || defaultConfiguration;\n\n// Count the number of fields\nlet totalFields = configuration.fields.length;\n\nconst catchableErrors = [\n    \"ENOTFOUND\",\n    \"ECONNRESET\",\n    \"ETIMEDOUT\",\n    \"EHOSTUNREACH\",\n    \"ECONNREFUSED\",\n    \"EAI_AGAIN\"\n];\n\nif (typeof msg.statusCode !== \"string\" && !catchableErrors.includes(msg.statusCode)) {\n\n    // Maintain a counter in the node context\n    let count = context.get('count') || 0;\n    count += 1;\n\n    // Check if the number of received messages matches the number of fields\n    if (count >= totalFields) {\n        context.set('count', 0); // Reset the counter\n        return msg; // Send the message\n    } else {\n        context.set('count', count); // Update the counter\n        return null; // Do not send anything\n    }\n} else {\n\n    return null;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3000,
        "y": 240,
        "wires": [
            [
                "f729eef64092723a"
            ]
        ]
    },
    {
        "id": "f729eef64092723a",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Create default email contact point",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/v1/provisioning/contact-points",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 3380,
        "y": 240,
        "wires": [
            [
                "772d21da4d18faaa"
            ]
        ]
    },
    {
        "id": "35a4610707e6bb3f",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "7ef98ba80c4027f0"
        ],
        "uncaught": false,
        "x": 2990,
        "y": 300,
        "wires": [
            [
                "c3c47677e7860708"
            ]
        ]
    },
    {
        "id": "c3c47677e7860708",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 3140,
        "y": 300,
        "wires": [
            [
                "f729eef64092723a"
            ]
        ]
    },
    {
        "id": "919ff3023be6c4f7",
        "type": "split",
        "z": "974a61a99863234b",
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "property": "payload",
        "x": 1570,
        "y": 500,
        "wires": [
            [
                "a741fac6b9bf910c"
            ]
        ]
    },
    {
        "id": "a741fac6b9bf910c",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Create dashboards",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/dashboards/db",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 1750,
        "y": 500,
        "wires": [
            [
                "b4d8627f632eeb5a"
            ]
        ]
    },
    {
        "id": "524b0ac8cb79597c",
        "type": "inject",
        "z": "974a61a99863234b",
        "name": "Generate Report Images Form Default Configuration",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 270,
        "y": 500,
        "wires": [
            [
                "bd278caffd098204"
            ]
        ]
    },
    {
        "id": "4237e9bc8e53ce2b",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Generate Grafana Dashboards",
        "func": "function convertIntervalToRefresh(intervalMs) {\n  const seconds = Math.floor(intervalMs / 1000);\n  return seconds + \"s\"; \n}\n\nfunction buildOverviewRow(fieldId) {\n  return {\n    \"type\": \"row\",\n    \"title\": `IoT Sensors Dashboard - Field ${fieldId}`,\n    \"collapsed\": false,\n    \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 0 },\n    \"id\": 999,\n    \"panels\": []\n  };\n}\n\nfunction buildTemperaturePanels(fieldId, thresholds) {\n  // Row \"Temperature\" + Barchart + Gauge\n  return [\n    {\n      \"collapsed\": false,\n      \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 16 },\n      \"id\": 20,\n      \"panels\": [],\n      \"title\": \"Temperature\",\n      \"type\": \"row\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"custom\": {\n            \"axisBorderShow\": false,\n            \"axisCenteredZero\": true,\n            \"axisColorMode\": \"text\",\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"fillOpacity\": 80,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n            \"lineWidth\": 1,\n            \"scaleDistribution\": { \"type\": \"linear\" },\n            \"thresholdsStyle\": { \"mode\": \"off\" }\n          },\n          \"mappings\": [],\n          \"max\": 45,\n          \"min\": -15,\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"red\", \"value\": null },\n              { \"color\": \"green\", \"value\": thresholds.min },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"celsius\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 19, \"x\": 0, \"y\": 17 },\n      \"id\": 21,\n      \"options\": {\n        \"barRadius\": 0,\n        \"barWidth\": 0.97,\n        \"colorByField\": `value {field_id=\"field${fieldId}\", sensor_type=\"temperature\", topic=\"agriculture/field${fieldId}/temperature\"}`,\n        \"fullHighlight\": true,\n        \"groupWidth\": 0.7,\n        \"legend\": {\n          \"calcs\": [],\n          \"displayMode\": \"list\",\n          \"placement\": \"bottom\",\n          \"showLegend\": true\n        },\n        \"orientation\": \"auto\",\n        \"showValue\": \"auto\",\n        \"stacking\": \"normal\",\n        \"tooltip\": { \"mode\": \"single\", \"sort\": \"none\" },\n        \"xTickLabelRotation\": 45,\n        \"xTickLabelSpacing\": -100\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"temperature\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": \"Temperature\",\n      \"type\": \"barchart\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"mappings\": [],\n          \"max\": 45,\n          \"min\": -15,\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"red\", \"value\": null },\n              { \"color\": \"green\", \"value\": thresholds.min },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"celsius\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 5, \"x\": 19, \"y\": 17 },\n      \"id\": 22,\n      \"options\": {\n        \"minVizHeight\": 75,\n        \"minVizWidth\": 75,\n        \"orientation\": \"auto\",\n        \"reduceOptions\": {\n          \"calcs\": [\"lastNotNull\"],\n          \"fields\": `/^value \\\\{field_id=\"field${fieldId}\", sensor_type=\"temperature\", topic=\"agriculture/field${fieldId}/temperature\"\\\\}$/`,\n          \"values\": false\n        },\n        \"showThresholdLabels\": false,\n        \"showThresholdMarkers\": true,\n        \"sizing\": \"auto\"\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"temperature\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": \"Temperature Gauge\",\n      \"type\": \"gauge\"\n    }\n  ];\n}\n\n// ---------- HUMIDITY -----------\nfunction buildHumidityPanels(fieldId, thresholds) {\n  return [\n    {\n      \"collapsed\": false,\n      \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 28 },\n      \"id\": 50,\n      \"panels\": [],\n      \"title\": \"Humidity\",\n      \"type\": \"row\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"thresholds\",\n            \"seriesBy\": \"last\"\n          },\n          \"custom\": {\n            \"axisBorderShow\": false,\n            \"axisCenteredZero\": false,\n            \"axisColorMode\": \"text\",\n            \"axisGridShow\": true,\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"barWidthFactor\": 0.6,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 0,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n            \"insertNulls\": false,\n            \"lineInterpolation\": \"linear\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": { \"type\": \"linear\" },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": { \"group\": \"A\", \"mode\": \"none\" },\n            \"thresholdsStyle\": { \"mode\": \"dashed+area\" }\n          },\n          \"mappings\": [],\n          \"max\": 100,\n          \"min\": 0,\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"red\", \"value\": null },\n              { \"color\": \"green\", \"value\": thresholds.min },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          }\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 19, \"x\": 0, \"y\": 29 },\n      \"id\": 51,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [],\n          \"displayMode\": \"list\",\n          \"placement\": \"bottom\",\n          \"showLegend\": false\n        },\n        \"tooltip\": { \"mode\": \"single\", \"sort\": \"none\" }\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"humidity\")\n  |> aggregateWindow(every: 1m, fn: mean, createEmpty: false)\n  |> yield(name: \"mean\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": \"Humidity\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"mappings\": [],\n          \"max\": 100,\n          \"min\": 0,\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"red\", \"value\": null },\n              { \"color\": \"green\", \"value\": thresholds.min },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"percent\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 5, \"x\": 19, \"y\": 29 },\n      \"id\": 52,\n      \"options\": {\n        \"colorMode\": \"value\",\n        \"graphMode\": \"area\",\n        \"justifyMode\": \"auto\",\n        \"orientation\": \"auto\",\n        \"percentChangeColorMode\": \"standard\",\n        \"reduceOptions\": {\n          \"calcs\": [\"lastNotNull\"],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"showPercentChange\": false,\n        \"textMode\": \"auto\",\n        \"wideLayout\": true\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"humidity\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": `Humidity`,\n      \"type\": \"stat\"\n    }\n  ];\n}\n\n// ---------- SOIL MOISTURE -----------\nfunction buildSoilMoisturePanels(fieldId, thresholds) {\n  return [\n    {\n      \"collapsed\": false,\n      \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 37 },\n      \"id\": 10,\n      \"panels\": [],\n      \"title\": \"Soil Moisture\",\n      \"type\": \"row\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"custom\": {\n            \"axisBorderShow\": false,\n            \"axisCenteredZero\": false,\n            \"axisColorMode\": \"text\",\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"fillOpacity\": 80,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n            \"lineWidth\": 1,\n            \"scaleDistribution\": { \"type\": \"linear\" },\n            \"thresholdsStyle\": { \"mode\": \"off\" }\n          },\n          \"mappings\": [],\n          \"max\": 100,\n          \"min\": 0,\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"red\", \"value\": null },\n              { \"color\": \"green\", \"value\": thresholds.min },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"percent\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 19, \"x\": 0, \"y\": 38 },\n      \"id\": 11,\n      \"options\": {\n        \"barRadius\": 0,\n        \"barWidth\": 1,\n        \"fullHighlight\": false,\n        \"groupWidth\": 0.7,\n        \"legend\": {\n          \"calcs\": [\"lastNotNull\"],\n          \"displayMode\": \"list\",\n          \"placement\": \"right\",\n          \"showLegend\": true\n        },\n        \"orientation\": \"auto\",\n        \"showValue\": \"auto\",\n        \"stacking\": \"none\",\n        \"tooltip\": { \"mode\": \"single\", \"sort\": \"none\" },\n        \"xTickLabelRotation\": 45,\n        \"xTickLabelSpacing\": -100\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"soilMoisture\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": `Soil Moisture`,\n      \"type\": \"barchart\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"mappings\": [],\n          \"max\": 100,\n          \"min\": 0,\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"red\", \"value\": null },\n              { \"color\": \"green\", \"value\": thresholds.min },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"percent\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 5, \"x\": 19, \"y\": 38 },\n      \"id\": 12,\n      \"options\": {\n        \"colorMode\": \"value\",\n        \"graphMode\": \"area\",\n        \"justifyMode\": \"auto\",\n        \"orientation\": \"auto\",\n        \"percentChangeColorMode\": \"standard\",\n        \"reduceOptions\": {\n          \"calcs\": [\"lastNotNull\"],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"showPercentChange\": false,\n        \"textMode\": \"auto\",\n        \"wideLayout\": true\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"soilMoisture\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": `Soil Moisture`,\n      \"type\": \"stat\"\n    }\n  ];\n}\n\n// ---------- pH -----------\nfunction buildPhPanels(fieldId, thresholds) {\n  return [\n    {\n      \"collapsed\": false,\n      \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 46 },\n      \"id\": 30,\n      \"panels\": [],\n      \"title\": \"Soil pH\",\n      \"type\": \"row\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"custom\": {\n            \"axisBorderShow\": false,\n            \"axisCenteredZero\": false,\n            \"axisColorMode\": \"text\",\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"barWidthFactor\": 0.6,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 0,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n            \"insertNulls\": false,\n            \"lineInterpolation\": \"linear\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": { \"type\": \"linear\" },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": { \"group\": \"A\", \"mode\": \"none\" },\n            \"thresholdsStyle\": { \"mode\": \"dashed+area\" }\n          },\n          \"fieldMinMax\": true,\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"red\" },\n              { \"color\": \"green\", \"value\": thresholds.min },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"pH\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 19, \"x\": 0, \"y\": 47 },\n      \"id\": 32,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [],\n          \"displayMode\": \"list\",\n          \"placement\": \"bottom\",\n          \"showLegend\": false\n        },\n        \"tooltip\": { \"mode\": \"single\", \"sort\": \"none\" }\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"ph\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": \"Soil pH\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"mappings\": [],\n          \"max\": 14,\n          \"min\": 0,\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"red\" },\n              { \"color\": \"green\", \"value\": thresholds.min },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"pH\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 5, \"x\": 19, \"y\": 47 },\n      \"id\": 31,\n      \"options\": {\n        \"minVizHeight\": 75,\n        \"minVizWidth\": 75,\n        \"orientation\": \"auto\",\n        \"reduceOptions\": {\n          \"calcs\": [\"lastNotNull\"],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"showThresholdLabels\": false,\n        \"showThresholdMarkers\": true,\n        \"sizing\": \"auto\"\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"ph\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": `Soil pH`,\n      \"type\": \"gauge\"\n    }\n  ];\n}\n\n// ---------- SALINITY -----------\nfunction buildSalinityPanels(fieldId, thresholds) {\n  return [\n    {\n      \"collapsed\": false,\n      \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 55 },\n      \"id\": 40,\n      \"panels\": [],\n      \"title\": \"Water Salinity\",\n      \"type\": \"row\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"custom\": {\n            \"axisBorderShow\": false,\n            \"axisCenteredZero\": false,\n            \"axisColorMode\": \"text\",\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"fillOpacity\": 80,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n            \"lineWidth\": 1,\n            \"scaleDistribution\": { \"type\": \"linear\" },\n            \"thresholdsStyle\": { \"mode\": \"off\" }\n          },\n          \"fieldMinMax\": true,\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"red\" },\n              { \"color\": \"green\", \"value\": thresholds.min },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"ŒºS/cm\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 19, \"x\": 0, \"y\": 56 },\n      \"id\": 42,\n      \"options\": {\n        \"barRadius\": 0,\n        \"barWidth\": 0.97,\n        \"fullHighlight\": false,\n        \"groupWidth\": 0.7,\n        \"legend\": {\n          \"calcs\": [],\n          \"displayMode\": \"list\",\n          \"placement\": \"right\",\n          \"showLegend\": true\n        },\n        \"orientation\": \"auto\",\n        \"showValue\": \"auto\",\n        \"stacking\": \"none\",\n        \"tooltip\": { \"mode\": \"single\", \"sort\": \"none\" },\n        \"xTickLabelRotation\": 45,\n        \"xTickLabelSpacing\": -100\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"salinity\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": `Water Salinity`,\n      \"type\": \"barchart\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"fieldMinMax\": true,\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"red\" },\n              { \"color\": \"green\", \"value\": thresholds.min },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"ŒºS/cm\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 5, \"x\": 19, \"y\": 56 },\n      \"id\": 41,\n      \"options\": {\n        \"displayMode\": \"gradient\",\n        \"legend\": {\n          \"calcs\": [],\n          \"displayMode\": \"list\",\n          \"placement\": \"bottom\",\n          \"showLegend\": false\n        },\n        \"maxVizHeight\": 300,\n        \"minVizHeight\": 16,\n        \"minVizWidth\": 8,\n        \"namePlacement\": \"auto\",\n        \"orientation\": \"auto\",\n        \"reduceOptions\": {\n          \"calcs\": [\"lastNotNull\"],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"showUnfilled\": false,\n        \"sizing\": \"auto\",\n        \"valueMode\": \"color\"\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"salinity\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": \"Water Salinity\",\n      \"type\": \"bargauge\"\n    }\n  ];\n}\n\n// ---------- RAIN -----------\nfunction buildRainPanels(fieldId, thresholds) {\n  return [\n    {\n      \"collapsed\": false,\n      \"gridPos\": { \"h\": 1, \"w\": 24, \"x\": 0, \"y\": 64 },\n      \"id\": 60,\n      \"panels\": [],\n      \"title\": \"Rain Detection\",\n      \"type\": \"row\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"custom\": {\n            \"fillOpacity\": 70,\n            \"hideFrom\": { \"legend\": false, \"tooltip\": false, \"viz\": false },\n            \"insertNulls\": false,\n            \"lineWidth\": 0,\n            \"spanNulls\": false\n          },\n          \"displayName\": \".\",\n          \"fieldMinMax\": false,\n          \"mappings\": [],\n          \"min\": 0,\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"green\" },\n              { \"color\": \"blue\", \"value\": 1 },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"lengthmm\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 19, \"x\": 0, \"y\": 65 },\n      \"id\": 62,\n      \"options\": {\n        \"alignValue\": \"left\",\n        \"legend\": {\n          \"displayMode\": \"list\",\n          \"placement\": \"right\",\n          \"showLegend\": true\n        },\n        \"mergeValues\": false,\n        \"rowHeight\": 0.9,\n        \"showValue\": \"auto\",\n        \"tooltip\": { \"mode\": \"multi\", \"sort\": \"none\" }\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"rain\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": \"Rain Detection State\",\n      \"type\": \"state-timeline\"\n    },\n    {\n      \"datasource\": { \"type\": \"influxdb\", \"uid\": \"fe9sepcaz6iv4a\" },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": { \"mode\": \"thresholds\" },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              { \"color\": \"green\" },\n              { \"color\": \"red\", \"value\": thresholds.max }\n            ]\n          },\n          \"unit\": \"mm\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": { \"h\": 9, \"w\": 5, \"x\": 19, \"y\": 65 },\n      \"id\": 61,\n      \"options\": {\n        \"colorMode\": \"value\",\n        \"graphMode\": \"area\",\n        \"justifyMode\": \"auto\",\n        \"orientation\": \"auto\",\n        \"percentChangeColorMode\": \"standard\",\n        \"reduceOptions\": {\n          \"calcs\": [\"lastNotNull\"],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"showPercentChange\": false,\n        \"textMode\": \"auto\",\n        \"wideLayout\": true\n      },\n      \"pluginVersion\": \"11.3.1\",\n      \"targets\": [\n        {\n          \"query\": `from(bucket: \"SA-FMS\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> filter(fn: (r) => r[\"field_id\"] == \"field${fieldId}\")\n  |> filter(fn: (r) => r[\"sensor_type\"] == \"rain\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")`,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": `Rain Detection`,\n      \"type\": \"stat\"\n    }\n  ];\n}\n\nfunction buildDashboardForField(fieldId, sensors, refreshValue, thresholds) {\n  let baseDashboard = {\n    \"dashboard\": {\n      \"annotations\": {\n        \"list\": [\n          {\n            \"builtIn\": 1,\n            \"datasource\": {\n              \"type\": \"grafana\",\n              \"uid\": \"-- Grafana --\"\n            },\n            \"enable\": true,\n            \"hide\": true,\n            \"iconColor\": \"rgba(0, 211, 255, 1)\",\n            \"name\": \"Annotations & Alerts\",\n            \"type\": \"dashboard\"\n          }\n        ]\n      },\n      \"editable\": true,\n      \"fiscalYearStartMonth\": 0,\n      \"graphTooltip\": 0,\n      \"links\": [],\n      \"panels\": [],\n      \"preload\": false,\n      \"refresh\": refreshValue,         \n      \"schemaVersion\": 1,\n      \"tags\": [],\n      \"templating\": { \"list\": [] },\n      \"time\": { \"from\": \"now-15m\", \"to\": \"now\" },\n      \"timepicker\": {},\n      \"timezone\": \"browser\",\n      \"title\": `IoT Sensors Dashboard - Field ${fieldId}`,\n      \"uid\": `temporary-iot-sensors-00${fieldId}`,  \n      \"version\": 31, \n      \"weekStart\": \"\"\n    },\n    \"folderUid\": \"Screenshot-Temporary-SA-FMS\",\n    \"isFolder\": false,\n    \"overwrite\": true\n  };\n\n  // (1) Row \"Overview\"\n  baseDashboard.dashboard.panels.push(buildOverviewRow(fieldId));\n\n  if (sensors.temperature) {\n    baseDashboard.dashboard.panels.push(...buildTemperaturePanels(fieldId, thresholds.temperature));\n  }\n  if (sensors.humidity) {\n    baseDashboard.dashboard.panels.push(...buildHumidityPanels(fieldId, thresholds.humidity));\n  }\n  if (sensors.soilMoisture) {\n    baseDashboard.dashboard.panels.push(...buildSoilMoisturePanels(fieldId, thresholds.soilMoisture));\n  }\n  if (sensors.ph) {\n    baseDashboard.dashboard.panels.push(...buildPhPanels(fieldId, thresholds.ph));\n  }\n  if (sensors.salinity) {\n    baseDashboard.dashboard.panels.push(...buildSalinityPanels(fieldId, thresholds.salinity));\n  }\n  if (sensors.rain) {\n    baseDashboard.dashboard.panels.push(...buildRainPanels(fieldId, thresholds.rain));\n  }\n\n  return baseDashboard;\n}\n\nlet conf = {\n  \"initialWeather\": \"CLOUDY\",\n  \"fields\": [\n    {\n      \"fieldId\": 1,\n      \"sensors\": {\n        \"soilMoisture\": true,\n        \"temperature\": true,\n        \"ph\": true,\n        \"salinity\": true,\n        \"humidity\": true,\n        \"rain\": true\n      }\n    },\n    {\n      \"fieldId\": 2,\n      \"sensors\": {\n        \"soilMoisture\": true,\n        \"temperature\": true,\n        \"ph\": false,\n        \"salinity\": false,\n        \"humidity\": true,\n        \"rain\": false\n      }\n    },\n    {\n      \"fieldId\": 3,\n      \"sensors\": {\n        \"soilMoisture\": true,\n        \"temperature\": true,\n        \"ph\": true,\n        \"salinity\": true,\n        \"humidity\": true,\n        \"rain\": true\n      }\n    }\n  ],\n  \"interval\": 5000\n};\n\nlet input = global.get(\"simulationConfiguration\") || conf;\n\nlet thresholds = {\n  \"soilMoisture\": {\n    \"min\": 20,\n    \"max\": 80\n  },\n  \"temperature\": {\n    \"min\": 0,\n    \"max\": 35\n  },\n  \"ph\": {\n    \"min\": 5.5,\n    \"max\": 7.5\n  },\n  \"salinity\": {\n    \"min\": 200,\n    \"max\": 1500\n  },\n  \"humidity\": {\n    \"min\": 50,\n    \"max\": 90\n  },\n  \"rain\": {\n    \"max\": 40\n  }\n};\n\nconst thresholdConfig = global.get(\"sensorsThreshold\") || thresholds;\n\nlet refreshStr = convertIntervalToRefresh(input.interval);\n\nlet dashboards = [];\n\nfor (let f of input.fields) {\n  let fieldId = f.fieldId;\n  let sensors = f.sensors;\n  let dash = buildDashboardForField(fieldId, sensors, refreshStr, thresholdConfig);\n  dashboards.push(dash);\n}\n\nmsg.payload = dashboards;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 500,
        "wires": [
            [
                "919ff3023be6c4f7"
            ]
        ]
    },
    {
        "id": "58e8d68f572da2fc",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Create the folder",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/folders",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 1090,
        "y": 500,
        "wires": [
            [
                "4237e9bc8e53ce2b"
            ]
        ]
    },
    {
        "id": "dbae42a3423a4afb",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Create the folder",
        "func": "let folder = {\n    \"description\": \"Smart Agriculture - Field Monitoring System temporary folder for screenshots\",\n    \"title\": \"Smart Agriculture - Field Monitoring System temporary folder for screenshots\",\n    \"uid\": \"Screenshot-Temporary-SA-FMS\"\n}\n\nmsg.payload = folder;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 500,
        "wires": [
            [
                "58e8d68f572da2fc"
            ]
        ]
    },
    {
        "id": "d06f170e61fbc795",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "58e8d68f572da2fc"
        ],
        "uncaught": false,
        "x": 770,
        "y": 560,
        "wires": [
            [
                "eb59001a0e06b4aa"
            ]
        ]
    },
    {
        "id": "eb59001a0e06b4aa",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 900,
        "y": 560,
        "wires": [
            [
                "58e8d68f572da2fc"
            ]
        ]
    },
    {
        "id": "0f23e2b1718294af",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "a741fac6b9bf910c"
        ],
        "uncaught": false,
        "x": 1430,
        "y": 560,
        "wires": [
            [
                "e60fe2d02e0c472c"
            ]
        ]
    },
    {
        "id": "e60fe2d02e0c472c",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1560,
        "y": 560,
        "wires": [
            [
                "a741fac6b9bf910c"
            ]
        ]
    },
    {
        "id": "b4d8627f632eeb5a",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Count dashboard create request and generate render request urls",
        "func": "let defaultConfiguration = {\n    \"initialWeather\": \"CLOUDY\",\n    \"fields\": [\n        {\n            \"fieldId\": 1,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        },\n        {\n            \"fieldId\": 2,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": false,\n                \"salinity\": false,\n                \"humidity\": true,\n                \"rain\": false\n            }\n        },\n        {\n            \"fieldId\": 3,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        }\n    ],\n    \"interval\": 5000\n};\n\nlet configuration = global.get(\"simulationConfiguration\") || defaultConfiguration;\n\nlet totalFields = configuration.fields.length;\n\nconst catchableErrors = [\n    \"ENOTFOUND\",\n    \"ECONNRESET\",\n    \"ETIMEDOUT\",\n    \"EHOSTUNREACH\",\n    \"ECONNREFUSED\",\n    \"EAI_AGAIN\"\n];\n\nif (typeof msg.statusCode !== \"string\" && !catchableErrors.includes(msg.statusCode)) {\n\n    let count = context.get('count') || 0;\n    count += 1;\n\n    if (count >= totalFields) {\n\n        let urlTemplate = \"http://grafana-SA-FMS:3000/render/d/iot-sensors-001/iot-sensors-dashboard-field-1?orgId=1&from=now-1d&to=now&timezone=browser&refresh=30m&width=2080&height=2400&kiosk=1\";\n\n        let heightMapping = {\n            6: \"2400\",\n            5: \"2020\",\n            4: \"1650\",\n            3: \"1250\",\n            2: \"880\",\n            1: \"500\",\n        };\n\n        context.set('count', 0); \n\n        let urls = configuration.fields.map(field => {\n            let activeSensorsCount = Object.values(field.sensors).filter(sensor => sensor).length;\n            let height = heightMapping[activeSensorsCount] || \"500\"; // Default to \"500\" if no match found\n\n            let updatedUrl = urlTemplate\n                .replace(\"iot-sensors-001\", `temporary-iot-sensors-00${field.fieldId}`)\n                .replace(\"iot-sensors-dashboard-field-1\", `iot-sensors-dashboard-field-${field.fieldId}`)\n                .replace(/height=\\d+/, `height=${height}`);\n\n            return updatedUrl;\n        });\n\n        msg.url = urls;\n        return msg;\n    } else {\n        context.set('count', count); \n        return null; \n    }\n\n} else {\n\n    return null;\n}\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2120,
        "y": 500,
        "wires": [
            [
                "6d2e1caaf390ae96"
            ]
        ]
    },
    {
        "id": "8632bef7c0548ec4",
        "type": "debug",
        "z": "974a61a99863234b",
        "name": "Result of Request Photo",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2950,
        "y": 540,
        "wires": []
    },
    {
        "id": "bee16908951a44d6",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Get dashboard image rendered",
        "method": "GET",
        "ret": "bin",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 2650,
        "y": 500,
        "wires": [
            [
                "8632bef7c0548ec4",
                "3751a27e921b6185",
                "cc5967097c596789"
            ]
        ]
    },
    {
        "id": "6d2e1caaf390ae96",
        "type": "split",
        "z": "974a61a99863234b",
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "property": "url",
        "x": 2450,
        "y": 500,
        "wires": [
            [
                "bee16908951a44d6"
            ]
        ]
    },
    {
        "id": "0e38b613b7161289",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Delete folder - dashboard - alert rules",
        "method": "DELETE",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/folders/Screenshot-Temporary-SA-FMS?forceDeleteRules=true",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 3230,
        "y": 500,
        "wires": [
            [
                "d46422b1b59aa715"
            ]
        ]
    },
    {
        "id": "3751a27e921b6185",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Count render request",
        "func": "msg = {};\nlet defaultConfiguration = {\n    \"initialWeather\": \"CLOUDY\",\n    \"fields\": [\n        {\n            \"fieldId\": 1,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        },\n        {\n            \"fieldId\": 2,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": false,\n                \"salinity\": false,\n                \"humidity\": true,\n                \"rain\": false\n            }\n        },\n        {\n            \"fieldId\": 3,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        }\n    ],\n    \"interval\": 5000\n};\n\nlet configuration = global.get(\"simulationConfiguration\") || defaultConfiguration;\n\nlet totalFields = configuration.fields.length;\n\nconst catchableErrors = [\n    \"ENOTFOUND\",\n    \"ECONNRESET\",\n    \"ETIMEDOUT\",\n    \"EHOSTUNREACH\",\n    \"ECONNREFUSED\",\n    \"EAI_AGAIN\"\n];\n\nif (typeof msg.statusCode !== \"string\" && !catchableErrors.includes(msg.statusCode)) {\n\n    let count = context.get('count') || 0;\n    count += 1;\n\n    if (count >= totalFields) {\n        context.set('count', 0); \n        msg.payload = \"Done!\";\n        return msg;\n    } else {\n        context.set('count', count); \n        return null;\n    }\n\n} else {\n\n    return null;\n}\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2940,
        "y": 500,
        "wires": [
            [
                "0e38b613b7161289"
            ]
        ]
    },
    {
        "id": "d46422b1b59aa715",
        "type": "debug",
        "z": "974a61a99863234b",
        "name": "Result of Generate Report Images Form Configuration",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 3630,
        "y": 500,
        "wires": []
    },
    {
        "id": "1142efbb683ccd10",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "a741fac6b9bf910c"
        ],
        "uncaught": false,
        "x": 2290,
        "y": 440,
        "wires": [
            [
                "a0a0f42656cadfad"
            ]
        ]
    },
    {
        "id": "a0a0f42656cadfad",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 2440,
        "y": 440,
        "wires": [
            [
                "bee16908951a44d6"
            ]
        ]
    },
    {
        "id": "258141c07cf4e638",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "a741fac6b9bf910c"
        ],
        "uncaught": false,
        "x": 2830,
        "y": 440,
        "wires": [
            [
                "2ac2bd30e141d81e"
            ]
        ]
    },
    {
        "id": "2ac2bd30e141d81e",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 2980,
        "y": 440,
        "wires": [
            [
                "0e38b613b7161289"
            ]
        ]
    },
    {
        "id": "c08784a7d0bdacfc",
        "type": "link in",
        "z": "974a61a99863234b",
        "name": "Set Grafana",
        "links": [
            "7a9b6ee89f80ec87"
        ],
        "x": 485,
        "y": 280,
        "wires": [
            [
                "8de4b9a40a8cc3dd"
            ]
        ]
    },
    {
        "id": "4a8dd89a69cb644a",
        "type": "link in",
        "z": "974a61a99863234b",
        "name": "Set Alert (Thresholds - Sensor)",
        "links": [
            "1afb0f3b103d6bbb"
        ],
        "x": 485,
        "y": 320,
        "wires": [
            [
                "8de4b9a40a8cc3dd"
            ]
        ]
    },
    {
        "id": "48158ff7c011f763",
        "type": "inject",
        "z": "974a61a99863234b",
        "name": "Run Check and Create Data Sorce",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 380,
        "y": 720,
        "wires": [
            [
                "ad9cd504de81cd16"
            ]
        ]
    },
    {
        "id": "ad9cd504de81cd16",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Get All source",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/datasources",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 640,
        "y": 740,
        "wires": [
            [
                "95335ac60dfd0cec"
            ]
        ]
    },
    {
        "id": "95335ac60dfd0cec",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Generate datasource if not exist",
        "func": "const datasource = {\n   \"uid\": \"fe9sepcaz6iv4a\",\n   \"orgId\": 1,\n   \"name\": \"influxdb1\",\n   \"type\": \"influxdb\",\n   \"typeName\": \"InfluxDB\",\n   \"typeLogoUrl\": \"public/app/plugins/datasource/influxdb/img/influxdb_logo.svg\",\n   \"access\": \"proxy\",\n   \"url\": \"http://influxdb-SA-FMS:8086\",\n   \"user\": \"\",\n   \"database\": \"\",\n   \"basicAuth\": false,\n   \"isDefault\": true,\n   \"jsonData\": {\n      \"httpMode\": \"POST\",\n      \"organization\": \"se4iot\",\n      \"token\": \"G-UFVBDaSWKvc8P9QWjfwna3q6-n6_vRHSmL0CvN9T0SCJNfT0YDPR_XxYfKTREDoAS-jeuq1TbX2KnawbDodA==\",\n      \"version\": \"Flux\"\n   },\n   \"readOnly\": false,\n   \"secureJsonData\": {\n      \"token\": \"G-UFVBDaSWKvc8P9QWjfwna3q6-n6_vRHSmL0CvN9T0SCJNfT0YDPR_XxYfKTREDoAS-jeuq1TbX2KnawbDodA==\"\n   }\n}\n\nconst n = [];\nif (Array.isArray(msg.payload) && msg.payload.length === 0) {\n   msg.payload = datasource;\n   return msg;\n}\n\nmsg.payload = null;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 740,
        "wires": [
            [
                "57e2707e35d112ab"
            ]
        ]
    },
    {
        "id": "edf446a38f6d46d6",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Create datasource",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/datasources",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 1430,
        "y": 720,
        "wires": [
            [
                "49ca0417ba761718"
            ]
        ]
    },
    {
        "id": "57e2707e35d112ab",
        "type": "switch",
        "z": "974a61a99863234b",
        "name": "Create Data Source Defined\\n Create Data Souce is Null",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "nnull"
            },
            {
                "t": "null"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1180,
        "y": 740,
        "wires": [
            [
                "edf446a38f6d46d6"
            ],
            [
                "49ca0417ba761718"
            ]
        ]
    },
    {
        "id": "cc5967097c596789",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Generate filename",
        "func": "function extractDashboardField(responseUrl) {\n    const match = responseUrl.match(/\\/d\\/[^\\/]+\\/([^\\?]+)/);\n\n    if (match && match[1]) {\n        return match[1];\n    } else {\n        return null; \n    }\n}\n// Debug\nif (global.get(\"internalDebug\")) {\n    node.warn(\"filename: \" + extractDashboardField(msg.responseUrl));\n}\nmsg.filename = extractDashboardField(msg.responseUrl);\nmsg.salvafile = `/data/out/${msg.filename}.png`;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2930,
        "y": 580,
        "wires": [
            [
                "93db5137e1f121d6",
                "9f6c0b285aa42713"
            ]
        ]
    },
    {
        "id": "93db5137e1f121d6",
        "type": "file",
        "z": "974a61a99863234b",
        "name": "",
        "filename": "salvafile",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 3140,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "7d76f6ba396887ab",
        "type": "link in",
        "z": "974a61a99863234b",
        "name": "Create Report Photo",
        "links": [
            "fe8844707189a25b"
        ],
        "x": 445,
        "y": 540,
        "wires": [
            [
                "bd278caffd098204"
            ]
        ]
    },
    {
        "id": "9f6c0b285aa42713",
        "type": "link out",
        "z": "974a61a99863234b",
        "name": "Output Generate Report Photo single",
        "mode": "link",
        "links": [
            "7cb34e23065ce05a"
        ],
        "x": 3095,
        "y": 620,
        "wires": []
    },
    {
        "id": "936d9e79608e8ca8",
        "type": "link in",
        "z": "974a61a99863234b",
        "name": "Check and crate Data Soruce",
        "links": [],
        "x": 505,
        "y": 760,
        "wires": [
            [
                "ad9cd504de81cd16"
            ]
        ]
    },
    {
        "id": "49ca0417ba761718",
        "type": "link out",
        "z": "974a61a99863234b",
        "name": "Return Check and crate Data Soruce",
        "mode": "return",
        "links": [],
        "x": 1555,
        "y": 760,
        "wires": []
    },
    {
        "id": "8de4b9a40a8cc3dd",
        "type": "link call",
        "z": "974a61a99863234b",
        "name": "Check Data Source",
        "links": [
            "936d9e79608e8ca8"
        ],
        "linkType": "static",
        "timeout": "30",
        "x": 630,
        "y": 240,
        "wires": [
            [
                "39c9855ab18c75ca"
            ]
        ]
    },
    {
        "id": "8b9671f00df0cbc0",
        "type": "debug",
        "z": "974a61a99863234b",
        "name": "Result Create Dashboard and Alerts form Configuration ",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 4590,
        "y": 240,
        "wires": []
    },
    {
        "id": "bd278caffd098204",
        "type": "link call",
        "z": "974a61a99863234b",
        "name": "Check Data Source",
        "links": [
            "936d9e79608e8ca8"
        ],
        "linkType": "static",
        "timeout": "30",
        "x": 650,
        "y": 500,
        "wires": [
            [
                "dbae42a3423a4afb"
            ]
        ]
    },
    {
        "id": "6e373b78b8eb5ec0",
        "type": "join",
        "z": "974a61a99863234b",
        "name": "Join Reults",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": false,
        "accumulate": false,
        "timeout": "10",
        "count": "",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 4270,
        "y": 240,
        "wires": [
            [
                "8b9671f00df0cbc0"
            ]
        ]
    },
    {
        "id": "8c53c56a3f1801b7",
        "type": "influxdb in",
        "z": "974a61a99863234b",
        "influxdb": "8cbf2748df1bc57f",
        "name": "Read InfluxDB ",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "se4iot",
        "x": 1160,
        "y": 980,
        "wires": [
            [
                "c44c79484e0491ff"
            ]
        ]
    },
    {
        "id": "a1e82e95017ee669",
        "type": "debug",
        "z": "974a61a99863234b",
        "name": "Result of Alerts",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 960,
        "wires": []
    },
    {
        "id": "6ee3b48b110d0e4b",
        "type": "trigger",
        "z": "974a61a99863234b",
        "name": "",
        "op1": "",
        "op2": "",
        "op1type": "pay",
        "op2type": "str",
        "duration": "-5",
        "extend": false,
        "overrideDelay": true,
        "units": "s",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 980,
        "y": 980,
        "wires": [
            [
                "8c53c56a3f1801b7"
            ]
        ]
    },
    {
        "id": "986d77efaa034807",
        "type": "link in",
        "z": "974a61a99863234b",
        "name": "start-sim",
        "links": [
            "c3658e8c395688ef"
        ],
        "x": 175,
        "y": 940,
        "wires": [
            [
                "7a33fd74f81c2ef8"
            ]
        ]
    },
    {
        "id": "3c24c8c58f47effd",
        "type": "link in",
        "z": "974a61a99863234b",
        "name": "stop-sim",
        "links": [
            "92afd731d3dbf926"
        ],
        "x": 175,
        "y": 1020,
        "wires": [
            [
                "47b60e0888e29fd9"
            ]
        ]
    },
    {
        "id": "47b60e0888e29fd9",
        "type": "change",
        "z": "974a61a99863234b",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "reset",
                "pt": "msg",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 720,
        "y": 1020,
        "wires": [
            [
                "6ee3b48b110d0e4b"
            ]
        ]
    },
    {
        "id": "7a33fd74f81c2ef8",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Get Configuration and Set delay",
        "func": "msg = {};\nconst configDefault = {\n    \"initialWeather\": \"CLOUDY\",\n    \"fields\": [\n        {\n            \"fieldId\": 1,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        },\n        {\n            \"fieldId\": 2,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": false,\n                \"salinity\": false,\n                \"humidity\": true,\n                \"rain\": false\n            }\n        },\n        {\n            \"fieldId\": 3,\n            \"sensors\": {\n                \"soilMoisture\": true,\n                \"temperature\": true,\n                \"ph\": true,\n                \"salinity\": true,\n                \"humidity\": true,\n                \"rain\": true\n            }\n        }\n    ],\n    \"interval\": 5000\n};\nconst config = global.get(\"simulationConfiguration\") || configDefault;\nmsg.delay = config.interval;\nmsg.querydelay = config.interval + 1000;\n\nflow.set(\"AlertStatus\", true);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 940,
        "wires": [
            [
                "36deb0dfaf441d2f"
            ]
        ]
    },
    {
        "id": "c44c79484e0491ff",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Thresholds Alert Checker",
        "func": "const thresholdsDefault = {\n    soilMoisture: { min: 20, max: 80 },\n    temperature: { min: 0, max: 35 },\n    ph: { min: 5.5, max: 7.5 },\n    salinity: { min: 200, max: 1500 },\n    humidity: { min: 30, max: 90 },\n    rain: { max: 40 }\n};\n\nconst thresholds = global.get(\"sensorsThreshold\") || thresholdsDefault;\n\nconst data = msg.payload;\n\nconst latestValues = {};\n\nconst alerts = [];\n\ndata.forEach(entry => {\n    const fieldId = entry.field_id;\n    const sensorType = entry.sensor_type;\n    const value = entry._value;\n    const timestamp = entry._time;\n\n    const limits = thresholds[sensorType];\n    if (!limits) return; \n\n    const isBelowMin = limits.min !== undefined && value < limits.min;\n    const isAboveMax = limits.max !== undefined && value > limits.max;\n\n    if (isBelowMin || isAboveMax) {\n        const key = `${fieldId}-${sensorType}`;\n\n        latestValues[key] = {\n            fieldId,\n            sensorType,\n            value,\n            timestamp,\n            threshold: isBelowMin ? `Min ${limits.min}` : `Max ${limits.max}`\n        };\n    }\n});\n\n\nfor (const key in latestValues) {\n    const alert = latestValues[key];\n    alerts.push(alert);\n}\n\nmsg.alerts = alerts;\nreturn msg;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 980,
        "wires": [
            [
                "a1e82e95017ee669",
                "65c9d6a615f74d27"
            ]
        ]
    },
    {
        "id": "36deb0dfaf441d2f",
        "type": "template",
        "z": "974a61a99863234b",
        "name": "Query InfluxDB",
        "field": "query",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "from(bucket: \"SA-FMS\")\n  |> range(start: -{{querydelay}}ms)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"smart_agriculture_measurements\")\n  |> group(columns: [\"field_id\", \"sensor_type\"])\n  |> last()",
        "output": "str",
        "x": 600,
        "y": 940,
        "wires": [
            [
                "7dd51a946aa36de0"
            ]
        ]
    },
    {
        "id": "faab4acb6862989d",
        "type": "link in",
        "z": "974a61a99863234b",
        "name": "Reset alert Config and Thresholds",
        "links": [
            "2e829639469c3d9d",
            "1afb0f3b103d6bbb",
            "1d4fa3ebecd6de4c"
        ],
        "x": 175,
        "y": 1080,
        "wires": [
            [
                "8b40d1bc6e7d701e"
            ]
        ]
    },
    {
        "id": "7e83e8630b5e54f0",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "Set Alert Status to false",
        "func": "flow.set(\"AlertStatus\", false);\nmsg = {};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 550,
        "y": 1080,
        "wires": [
            [
                "47b60e0888e29fd9"
            ]
        ]
    },
    {
        "id": "8b40d1bc6e7d701e",
        "type": "switch",
        "z": "974a61a99863234b",
        "name": "if Alert is Running",
        "property": "AlertStatus",
        "propertyType": "flow",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 300,
        "y": 1080,
        "wires": [
            [
                "7a33fd74f81c2ef8",
                "7e83e8630b5e54f0"
            ],
            []
        ]
    },
    {
        "id": "65c9d6a615f74d27",
        "type": "link out",
        "z": "974a61a99863234b",
        "name": "Send Telegram Alert",
        "mode": "link",
        "links": [
            "1e59b061de9325aa"
        ],
        "x": 1575,
        "y": 1000,
        "wires": []
    },
    {
        "id": "7dd51a946aa36de0",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "variable or 5s",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 780,
        "y": 940,
        "wires": [
            [
                "6ee3b48b110d0e4b"
            ]
        ]
    },
    {
        "id": "b80b58d3eab270de",
        "type": "http request",
        "z": "974a61a99863234b",
        "name": "Delete default email contact point",
        "method": "DELETE",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://grafana-SA-FMS:3000/api/v1/provisioning/contact-points/default-contact-point",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer glsa_BBfglZ2IKTrksFMjPZq4pzk6U7yM9lTP_46936d3b"
            }
        ],
        "x": 1520,
        "y": 240,
        "wires": [
            [
                "9db46381144a9ef5"
            ]
        ]
    },
    {
        "id": "4f191a27b1698586",
        "type": "inject",
        "z": "974a61a99863234b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1460,
        "y": 1180,
        "wires": [
            [
                "258eec86a02c265d"
            ]
        ]
    },
    {
        "id": "258eec86a02c265d",
        "type": "function",
        "z": "974a61a99863234b",
        "name": "function 1",
        "func": "global.get(\"chats\")[0][1].active = false;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1660,
        "y": 1180,
        "wires": [
            []
        ]
    },
    {
        "id": "1994574f46f6f984",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "ad9cd504de81cd16"
        ],
        "uncaught": false,
        "x": 350,
        "y": 660,
        "wires": [
            [
                "29a0b2fe84efd320"
            ]
        ]
    },
    {
        "id": "29a0b2fe84efd320",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 480,
        "y": 660,
        "wires": [
            [
                "ad9cd504de81cd16"
            ]
        ]
    },
    {
        "id": "04715dcb18d78ec6",
        "type": "catch",
        "z": "974a61a99863234b",
        "name": "",
        "scope": [
            "edf446a38f6d46d6"
        ],
        "uncaught": false,
        "x": 1130,
        "y": 660,
        "wires": [
            [
                "65b24075c34644d6"
            ]
        ]
    },
    {
        "id": "65b24075c34644d6",
        "type": "delay",
        "z": "974a61a99863234b",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1260,
        "y": 660,
        "wires": [
            [
                "edf446a38f6d46d6"
            ]
        ]
    }
]